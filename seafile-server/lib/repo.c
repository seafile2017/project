/* repo.c generated by valac 0.34.4, the Vala compiler
 * generated from repo.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <string.h>


#define SEAFILE_TYPE_REPO (seafile_repo_get_type ())
#define SEAFILE_REPO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_REPO, SeafileRepo))
#define SEAFILE_REPO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_REPO, SeafileRepoClass))
#define SEAFILE_IS_REPO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_REPO))
#define SEAFILE_IS_REPO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_REPO))
#define SEAFILE_REPO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_REPO, SeafileRepoClass))

typedef struct _SeafileRepo SeafileRepo;
typedef struct _SeafileRepoClass SeafileRepoClass;
typedef struct _SeafileRepoPrivate SeafileRepoPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define SEAFILE_TYPE_TRASH_REPO (seafile_trash_repo_get_type ())
#define SEAFILE_TRASH_REPO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepo))
#define SEAFILE_TRASH_REPO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepoClass))
#define SEAFILE_IS_TRASH_REPO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_TRASH_REPO))
#define SEAFILE_IS_TRASH_REPO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_TRASH_REPO))
#define SEAFILE_TRASH_REPO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepoClass))

typedef struct _SeafileTrashRepo SeafileTrashRepo;
typedef struct _SeafileTrashRepoClass SeafileTrashRepoClass;
typedef struct _SeafileTrashRepoPrivate SeafileTrashRepoPrivate;

#define SEAFILE_TYPE_SYNC_INFO (seafile_sync_info_get_type ())
#define SEAFILE_SYNC_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfo))
#define SEAFILE_SYNC_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfoClass))
#define SEAFILE_IS_SYNC_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_SYNC_INFO))
#define SEAFILE_IS_SYNC_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_SYNC_INFO))
#define SEAFILE_SYNC_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfoClass))

typedef struct _SeafileSyncInfo SeafileSyncInfo;
typedef struct _SeafileSyncInfoClass SeafileSyncInfoClass;
typedef struct _SeafileSyncInfoPrivate SeafileSyncInfoPrivate;

#define SEAFILE_TYPE_SYNC_TASK (seafile_sync_task_get_type ())
#define SEAFILE_SYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_SYNC_TASK, SeafileSyncTask))
#define SEAFILE_SYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_SYNC_TASK, SeafileSyncTaskClass))
#define SEAFILE_IS_SYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_SYNC_TASK))
#define SEAFILE_IS_SYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_SYNC_TASK))
#define SEAFILE_SYNC_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_SYNC_TASK, SeafileSyncTaskClass))

typedef struct _SeafileSyncTask SeafileSyncTask;
typedef struct _SeafileSyncTaskClass SeafileSyncTaskClass;
typedef struct _SeafileSyncTaskPrivate SeafileSyncTaskPrivate;

#define SEAFILE_TYPE_SESSION_INFO (seafile_session_info_get_type ())
#define SEAFILE_SESSION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfo))
#define SEAFILE_SESSION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfoClass))
#define SEAFILE_IS_SESSION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_SESSION_INFO))
#define SEAFILE_IS_SESSION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_SESSION_INFO))
#define SEAFILE_SESSION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfoClass))

typedef struct _SeafileSessionInfo SeafileSessionInfo;
typedef struct _SeafileSessionInfoClass SeafileSessionInfoClass;
typedef struct _SeafileSessionInfoPrivate SeafileSessionInfoPrivate;

#define SEAFILE_TYPE_CHECKOUT_TASK (seafile_checkout_task_get_type ())
#define SEAFILE_CHECKOUT_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTask))
#define SEAFILE_CHECKOUT_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTaskClass))
#define SEAFILE_IS_CHECKOUT_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_CHECKOUT_TASK))
#define SEAFILE_IS_CHECKOUT_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_CHECKOUT_TASK))
#define SEAFILE_CHECKOUT_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTaskClass))

typedef struct _SeafileCheckoutTask SeafileCheckoutTask;
typedef struct _SeafileCheckoutTaskClass SeafileCheckoutTaskClass;
typedef struct _SeafileCheckoutTaskPrivate SeafileCheckoutTaskPrivate;

#define SEAFILE_TYPE_DIFF_ENTRY (seafile_diff_entry_get_type ())
#define SEAFILE_DIFF_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntry))
#define SEAFILE_DIFF_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntryClass))
#define SEAFILE_IS_DIFF_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_DIFF_ENTRY))
#define SEAFILE_IS_DIFF_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_DIFF_ENTRY))
#define SEAFILE_DIFF_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntryClass))

typedef struct _SeafileDiffEntry SeafileDiffEntry;
typedef struct _SeafileDiffEntryClass SeafileDiffEntryClass;
typedef struct _SeafileDiffEntryPrivate SeafileDiffEntryPrivate;

#define SEAFILE_TYPE_DELETED_ENTRY (seafile_deleted_entry_get_type ())
#define SEAFILE_DELETED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntry))
#define SEAFILE_DELETED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntryClass))
#define SEAFILE_IS_DELETED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_DELETED_ENTRY))
#define SEAFILE_IS_DELETED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_DELETED_ENTRY))
#define SEAFILE_DELETED_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntryClass))

typedef struct _SeafileDeletedEntry SeafileDeletedEntry;
typedef struct _SeafileDeletedEntryClass SeafileDeletedEntryClass;
typedef struct _SeafileDeletedEntryPrivate SeafileDeletedEntryPrivate;

#define SEAFILE_TYPE_REPO_TOKEN_INFO (seafile_repo_token_info_get_type ())
#define SEAFILE_REPO_TOKEN_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfo))
#define SEAFILE_REPO_TOKEN_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfoClass))
#define SEAFILE_IS_REPO_TOKEN_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_REPO_TOKEN_INFO))
#define SEAFILE_IS_REPO_TOKEN_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_REPO_TOKEN_INFO))
#define SEAFILE_REPO_TOKEN_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfoClass))

typedef struct _SeafileRepoTokenInfo SeafileRepoTokenInfo;
typedef struct _SeafileRepoTokenInfoClass SeafileRepoTokenInfoClass;
typedef struct _SeafileRepoTokenInfoPrivate SeafileRepoTokenInfoPrivate;

#define SEAFILE_TYPE_SHARED_USER (seafile_shared_user_get_type ())
#define SEAFILE_SHARED_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_SHARED_USER, SeafileSharedUser))
#define SEAFILE_SHARED_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_SHARED_USER, SeafileSharedUserClass))
#define SEAFILE_IS_SHARED_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_SHARED_USER))
#define SEAFILE_IS_SHARED_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_SHARED_USER))
#define SEAFILE_SHARED_USER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_SHARED_USER, SeafileSharedUserClass))

typedef struct _SeafileSharedUser SeafileSharedUser;
typedef struct _SeafileSharedUserClass SeafileSharedUserClass;
typedef struct _SeafileSharedUserPrivate SeafileSharedUserPrivate;

#define SEAFILE_TYPE_SHARED_GROUP (seafile_shared_group_get_type ())
#define SEAFILE_SHARED_GROUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroup))
#define SEAFILE_SHARED_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroupClass))
#define SEAFILE_IS_SHARED_GROUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_SHARED_GROUP))
#define SEAFILE_IS_SHARED_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_SHARED_GROUP))
#define SEAFILE_SHARED_GROUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroupClass))

typedef struct _SeafileSharedGroup SeafileSharedGroup;
typedef struct _SeafileSharedGroupClass SeafileSharedGroupClass;
typedef struct _SeafileSharedGroupPrivate SeafileSharedGroupPrivate;

#define SEAFILE_TYPE_ENCRYPTION_INFO (seafile_encryption_info_get_type ())
#define SEAFILE_ENCRYPTION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfo))
#define SEAFILE_ENCRYPTION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfoClass))
#define SEAFILE_IS_ENCRYPTION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_ENCRYPTION_INFO))
#define SEAFILE_IS_ENCRYPTION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_ENCRYPTION_INFO))
#define SEAFILE_ENCRYPTION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfoClass))

typedef struct _SeafileEncryptionInfo SeafileEncryptionInfo;
typedef struct _SeafileEncryptionInfoClass SeafileEncryptionInfoClass;
typedef struct _SeafileEncryptionInfoPrivate SeafileEncryptionInfoPrivate;

struct _SeafileRepo {
	GObject parent_instance;
	SeafileRepoPrivate * priv;
	gchar _id[37];
	gchar* _name;
	gchar* _desc;
	gchar* _worktree;
	gchar* _relay_id;
};

struct _SeafileRepoClass {
	GObjectClass parent_class;
};

struct _SeafileRepoPrivate {
	gint _version;
	gint _last_modify;
	gint64 _size;
	gint64 _file_count;
	gchar* _head_cmmt_id;
	gchar* _root;
	gchar* _repo_id;
	gchar* _repo_name;
	gchar* _repo_desc;
	gint _last_modified;
	gboolean _encrypted;
	gchar* _magic;
	gint _enc_version;
	gchar* _random_key;
	gint _last_sync_time;
	gboolean _auto_sync;
	gboolean _worktree_invalid;
	gboolean _is_virtual;
	gchar* _origin_repo_id;
	gchar* _origin_repo_name;
	gchar* _origin_path;
	gboolean _is_original_owner;
	gchar* _virtual_perm;
	gchar* _store_id;
	gboolean _is_corrupted;
	gboolean _repaired;
	gchar* _share_type;
	gchar* _permission;
	gchar* _user;
	gint _group_id;
	gboolean _is_shared;
};

struct _SeafileTrashRepo {
	GObject parent_instance;
	SeafileTrashRepoPrivate * priv;
};

struct _SeafileTrashRepoClass {
	GObjectClass parent_class;
};

struct _SeafileTrashRepoPrivate {
	gchar* _repo_id;
	gchar* _repo_name;
	gchar* _head_id;
	gchar* _owner_id;
	gint64 _size;
	gint64 _del_time;
};

struct _SeafileSyncInfo {
	GObject parent_instance;
	SeafileSyncInfoPrivate * priv;
};

struct _SeafileSyncInfoClass {
	GObjectClass parent_class;
};

struct _SeafileSyncInfoPrivate {
	gchar* _repo_id;
	gchar* _head_commit;
	gboolean _deleted_on_relay;
	gboolean _bad_local_branch;
	gboolean _need_fetch;
	gboolean _need_upload;
	gboolean _need_merge;
};

struct _SeafileSyncTask {
	GObject parent_instance;
	SeafileSyncTaskPrivate * priv;
};

struct _SeafileSyncTaskClass {
	GObjectClass parent_class;
};

struct _SeafileSyncTaskPrivate {
	gboolean _is_sync_lan;
	gboolean _force_upload;
	gchar* _dest_id;
	gchar* _repo_id;
	gchar* _state;
	gchar* _error;
	gchar* _tx_id;
};

struct _SeafileSessionInfo {
	GObject parent_instance;
	SeafileSessionInfoPrivate * priv;
};

struct _SeafileSessionInfoClass {
	GObjectClass parent_class;
};

struct _SeafileSessionInfoPrivate {
	gchar* _datadir;
};

struct _SeafileCheckoutTask {
	GObject parent_instance;
	SeafileCheckoutTaskPrivate * priv;
};

struct _SeafileCheckoutTaskClass {
	GObjectClass parent_class;
};

struct _SeafileCheckoutTaskPrivate {
	gchar* _repo_id;
	gchar* _worktree;
	gint _total_files;
	gint _finished_files;
};

struct _SeafileDiffEntry {
	GObject parent_instance;
	SeafileDiffEntryPrivate * priv;
};

struct _SeafileDiffEntryClass {
	GObjectClass parent_class;
};

struct _SeafileDiffEntryPrivate {
	gchar* _status;
	gchar* _name;
	gchar* _new_name;
};

struct _SeafileDeletedEntry {
	GObject parent_instance;
	SeafileDeletedEntryPrivate * priv;
};

struct _SeafileDeletedEntryClass {
	GObjectClass parent_class;
};

struct _SeafileDeletedEntryPrivate {
	gchar* _commit_id;
	gchar* _obj_id;
	gchar* _obj_name;
	gchar* _basedir;
	gint _mode;
	gint _delete_time;
	gint64 _file_size;
	gchar* _scan_stat;
};

struct _SeafileRepoTokenInfo {
	GObject parent_instance;
	SeafileRepoTokenInfoPrivate * priv;
};

struct _SeafileRepoTokenInfoClass {
	GObjectClass parent_class;
};

struct _SeafileRepoTokenInfoPrivate {
	gchar* _repo_id;
	gchar* _repo_name;
	gchar* _repo_owner;
	gchar* _email;
	gchar* _token;
	gchar* _peer_id;
	gchar* _peer_ip;
	gchar* _peer_name;
	gint64 _sync_time;
	gchar* _client_ver;
};

struct _SeafileSharedUser {
	GObject parent_instance;
	SeafileSharedUserPrivate * priv;
};

struct _SeafileSharedUserClass {
	GObjectClass parent_class;
};

struct _SeafileSharedUserPrivate {
	gchar* _repo_id;
	gchar* _user;
	gchar* _perm;
};

struct _SeafileSharedGroup {
	GObject parent_instance;
	SeafileSharedGroupPrivate * priv;
};

struct _SeafileSharedGroupClass {
	GObjectClass parent_class;
};

struct _SeafileSharedGroupPrivate {
	gchar* _repo_id;
	gint _group_id;
	gchar* _perm;
};

struct _SeafileEncryptionInfo {
	GObject parent_instance;
	SeafileEncryptionInfoPrivate * priv;
};

struct _SeafileEncryptionInfoClass {
	GObjectClass parent_class;
};

struct _SeafileEncryptionInfoPrivate {
	gchar* _repo_id;
	gchar* _passwd;
	gint _enc_version;
	gchar* _magic;
	gchar* _random_key;
};


static gpointer seafile_repo_parent_class = NULL;
static gpointer seafile_trash_repo_parent_class = NULL;
static gpointer seafile_sync_info_parent_class = NULL;
static gpointer seafile_sync_task_parent_class = NULL;
static gpointer seafile_session_info_parent_class = NULL;
static gpointer seafile_checkout_task_parent_class = NULL;
static gpointer seafile_diff_entry_parent_class = NULL;
static gpointer seafile_deleted_entry_parent_class = NULL;
static gpointer seafile_repo_token_info_parent_class = NULL;
static gpointer seafile_shared_user_parent_class = NULL;
static gpointer seafile_shared_group_parent_class = NULL;
static gpointer seafile_encryption_info_parent_class = NULL;

GType seafile_repo_get_type (void) G_GNUC_CONST;
#define SEAFILE_REPO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_REPO, SeafileRepoPrivate))
enum  {
	SEAFILE_REPO_DUMMY_PROPERTY,
	SEAFILE_REPO_ID,
	SEAFILE_REPO_NAME,
	SEAFILE_REPO_DESC,
	SEAFILE_REPO_VERSION,
	SEAFILE_REPO_LAST_MODIFY,
	SEAFILE_REPO_SIZE,
	SEAFILE_REPO_FILE_COUNT,
	SEAFILE_REPO_HEAD_CMMT_ID,
	SEAFILE_REPO_ROOT,
	SEAFILE_REPO_REPO_ID,
	SEAFILE_REPO_REPO_NAME,
	SEAFILE_REPO_REPO_DESC,
	SEAFILE_REPO_LAST_MODIFIED,
	SEAFILE_REPO_ENCRYPTED,
	SEAFILE_REPO_MAGIC,
	SEAFILE_REPO_ENC_VERSION,
	SEAFILE_REPO_RANDOM_KEY,
	SEAFILE_REPO_WORKTREE,
	SEAFILE_REPO_RELAY_ID,
	SEAFILE_REPO_LAST_SYNC_TIME,
	SEAFILE_REPO_AUTO_SYNC,
	SEAFILE_REPO_WORKTREE_INVALID,
	SEAFILE_REPO_IS_VIRTUAL,
	SEAFILE_REPO_ORIGIN_REPO_ID,
	SEAFILE_REPO_ORIGIN_REPO_NAME,
	SEAFILE_REPO_ORIGIN_PATH,
	SEAFILE_REPO_IS_ORIGINAL_OWNER,
	SEAFILE_REPO_VIRTUAL_PERM,
	SEAFILE_REPO_STORE_ID,
	SEAFILE_REPO_IS_CORRUPTED,
	SEAFILE_REPO_REPAIRED,
	SEAFILE_REPO_SHARE_TYPE,
	SEAFILE_REPO_PERMISSION,
	SEAFILE_REPO_USER,
	SEAFILE_REPO_GROUP_ID,
	SEAFILE_REPO_IS_SHARED
};
SeafileRepo* seafile_repo_new (void);
SeafileRepo* seafile_repo_construct (GType object_type);
const gchar* seafile_repo_get_id (SeafileRepo* self);
void seafile_repo_set_id (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_name (SeafileRepo* self);
void seafile_repo_set_name (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_desc (SeafileRepo* self);
void seafile_repo_set_desc (SeafileRepo* self, const gchar* value);
gint seafile_repo_get_version (SeafileRepo* self);
void seafile_repo_set_version (SeafileRepo* self, gint value);
gint seafile_repo_get_last_modify (SeafileRepo* self);
void seafile_repo_set_last_modify (SeafileRepo* self, gint value);
gint64 seafile_repo_get_size (SeafileRepo* self);
void seafile_repo_set_size (SeafileRepo* self, gint64 value);
gint64 seafile_repo_get_file_count (SeafileRepo* self);
void seafile_repo_set_file_count (SeafileRepo* self, gint64 value);
const gchar* seafile_repo_get_head_cmmt_id (SeafileRepo* self);
void seafile_repo_set_head_cmmt_id (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_root (SeafileRepo* self);
void seafile_repo_set_root (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_repo_id (SeafileRepo* self);
void seafile_repo_set_repo_id (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_repo_name (SeafileRepo* self);
void seafile_repo_set_repo_name (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_repo_desc (SeafileRepo* self);
void seafile_repo_set_repo_desc (SeafileRepo* self, const gchar* value);
gint seafile_repo_get_last_modified (SeafileRepo* self);
void seafile_repo_set_last_modified (SeafileRepo* self, gint value);
gboolean seafile_repo_get_encrypted (SeafileRepo* self);
void seafile_repo_set_encrypted (SeafileRepo* self, gboolean value);
const gchar* seafile_repo_get_magic (SeafileRepo* self);
void seafile_repo_set_magic (SeafileRepo* self, const gchar* value);
gint seafile_repo_get_enc_version (SeafileRepo* self);
void seafile_repo_set_enc_version (SeafileRepo* self, gint value);
const gchar* seafile_repo_get_random_key (SeafileRepo* self);
void seafile_repo_set_random_key (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_worktree (SeafileRepo* self);
void seafile_repo_set_worktree (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_relay_id (SeafileRepo* self);
void seafile_repo_set_relay_id (SeafileRepo* self, const gchar* value);
gint seafile_repo_get_last_sync_time (SeafileRepo* self);
void seafile_repo_set_last_sync_time (SeafileRepo* self, gint value);
gboolean seafile_repo_get_auto_sync (SeafileRepo* self);
void seafile_repo_set_auto_sync (SeafileRepo* self, gboolean value);
gboolean seafile_repo_get_worktree_invalid (SeafileRepo* self);
void seafile_repo_set_worktree_invalid (SeafileRepo* self, gboolean value);
gboolean seafile_repo_get_is_virtual (SeafileRepo* self);
void seafile_repo_set_is_virtual (SeafileRepo* self, gboolean value);
const gchar* seafile_repo_get_origin_repo_id (SeafileRepo* self);
void seafile_repo_set_origin_repo_id (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_origin_repo_name (SeafileRepo* self);
void seafile_repo_set_origin_repo_name (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_origin_path (SeafileRepo* self);
void seafile_repo_set_origin_path (SeafileRepo* self, const gchar* value);
gboolean seafile_repo_get_is_original_owner (SeafileRepo* self);
void seafile_repo_set_is_original_owner (SeafileRepo* self, gboolean value);
const gchar* seafile_repo_get_virtual_perm (SeafileRepo* self);
void seafile_repo_set_virtual_perm (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_store_id (SeafileRepo* self);
void seafile_repo_set_store_id (SeafileRepo* self, const gchar* value);
gboolean seafile_repo_get_is_corrupted (SeafileRepo* self);
void seafile_repo_set_is_corrupted (SeafileRepo* self, gboolean value);
gboolean seafile_repo_get_repaired (SeafileRepo* self);
void seafile_repo_set_repaired (SeafileRepo* self, gboolean value);
const gchar* seafile_repo_get_share_type (SeafileRepo* self);
void seafile_repo_set_share_type (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_permission (SeafileRepo* self);
void seafile_repo_set_permission (SeafileRepo* self, const gchar* value);
const gchar* seafile_repo_get_user (SeafileRepo* self);
void seafile_repo_set_user (SeafileRepo* self, const gchar* value);
gint seafile_repo_get_group_id (SeafileRepo* self);
void seafile_repo_set_group_id (SeafileRepo* self, gint value);
gboolean seafile_repo_get_is_shared (SeafileRepo* self);
void seafile_repo_set_is_shared (SeafileRepo* self, gboolean value);
static void seafile_repo_finalize (GObject* obj);
static void _vala_seafile_repo_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_repo_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_trash_repo_get_type (void) G_GNUC_CONST;
#define SEAFILE_TRASH_REPO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepoPrivate))
enum  {
	SEAFILE_TRASH_REPO_DUMMY_PROPERTY,
	SEAFILE_TRASH_REPO_REPO_ID,
	SEAFILE_TRASH_REPO_REPO_NAME,
	SEAFILE_TRASH_REPO_HEAD_ID,
	SEAFILE_TRASH_REPO_OWNER_ID,
	SEAFILE_TRASH_REPO_SIZE,
	SEAFILE_TRASH_REPO_DEL_TIME
};
SeafileTrashRepo* seafile_trash_repo_new (void);
SeafileTrashRepo* seafile_trash_repo_construct (GType object_type);
const gchar* seafile_trash_repo_get_repo_id (SeafileTrashRepo* self);
void seafile_trash_repo_set_repo_id (SeafileTrashRepo* self, const gchar* value);
const gchar* seafile_trash_repo_get_repo_name (SeafileTrashRepo* self);
void seafile_trash_repo_set_repo_name (SeafileTrashRepo* self, const gchar* value);
const gchar* seafile_trash_repo_get_head_id (SeafileTrashRepo* self);
void seafile_trash_repo_set_head_id (SeafileTrashRepo* self, const gchar* value);
const gchar* seafile_trash_repo_get_owner_id (SeafileTrashRepo* self);
void seafile_trash_repo_set_owner_id (SeafileTrashRepo* self, const gchar* value);
gint64 seafile_trash_repo_get_size (SeafileTrashRepo* self);
void seafile_trash_repo_set_size (SeafileTrashRepo* self, gint64 value);
gint64 seafile_trash_repo_get_del_time (SeafileTrashRepo* self);
void seafile_trash_repo_set_del_time (SeafileTrashRepo* self, gint64 value);
static void seafile_trash_repo_finalize (GObject* obj);
static void _vala_seafile_trash_repo_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_trash_repo_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_sync_info_get_type (void) G_GNUC_CONST;
#define SEAFILE_SYNC_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfoPrivate))
enum  {
	SEAFILE_SYNC_INFO_DUMMY_PROPERTY,
	SEAFILE_SYNC_INFO_REPO_ID,
	SEAFILE_SYNC_INFO_HEAD_COMMIT,
	SEAFILE_SYNC_INFO_DELETED_ON_RELAY,
	SEAFILE_SYNC_INFO_BAD_LOCAL_BRANCH,
	SEAFILE_SYNC_INFO_NEED_FETCH,
	SEAFILE_SYNC_INFO_NEED_UPLOAD,
	SEAFILE_SYNC_INFO_NEED_MERGE
};
SeafileSyncInfo* seafile_sync_info_new (void);
SeafileSyncInfo* seafile_sync_info_construct (GType object_type);
const gchar* seafile_sync_info_get_repo_id (SeafileSyncInfo* self);
void seafile_sync_info_set_repo_id (SeafileSyncInfo* self, const gchar* value);
const gchar* seafile_sync_info_get_head_commit (SeafileSyncInfo* self);
void seafile_sync_info_set_head_commit (SeafileSyncInfo* self, const gchar* value);
gboolean seafile_sync_info_get_deleted_on_relay (SeafileSyncInfo* self);
void seafile_sync_info_set_deleted_on_relay (SeafileSyncInfo* self, gboolean value);
gboolean seafile_sync_info_get_bad_local_branch (SeafileSyncInfo* self);
void seafile_sync_info_set_bad_local_branch (SeafileSyncInfo* self, gboolean value);
gboolean seafile_sync_info_get_need_fetch (SeafileSyncInfo* self);
void seafile_sync_info_set_need_fetch (SeafileSyncInfo* self, gboolean value);
gboolean seafile_sync_info_get_need_upload (SeafileSyncInfo* self);
void seafile_sync_info_set_need_upload (SeafileSyncInfo* self, gboolean value);
gboolean seafile_sync_info_get_need_merge (SeafileSyncInfo* self);
void seafile_sync_info_set_need_merge (SeafileSyncInfo* self, gboolean value);
static void seafile_sync_info_finalize (GObject* obj);
static void _vala_seafile_sync_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_sync_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_sync_task_get_type (void) G_GNUC_CONST;
#define SEAFILE_SYNC_TASK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_SYNC_TASK, SeafileSyncTaskPrivate))
enum  {
	SEAFILE_SYNC_TASK_DUMMY_PROPERTY,
	SEAFILE_SYNC_TASK_IS_SYNC_LAN,
	SEAFILE_SYNC_TASK_FORCE_UPLOAD,
	SEAFILE_SYNC_TASK_DEST_ID,
	SEAFILE_SYNC_TASK_REPO_ID,
	SEAFILE_SYNC_TASK_STATE,
	SEAFILE_SYNC_TASK_ERROR,
	SEAFILE_SYNC_TASK_TX_ID
};
SeafileSyncTask* seafile_sync_task_new (void);
SeafileSyncTask* seafile_sync_task_construct (GType object_type);
gboolean seafile_sync_task_get_is_sync_lan (SeafileSyncTask* self);
void seafile_sync_task_set_is_sync_lan (SeafileSyncTask* self, gboolean value);
gboolean seafile_sync_task_get_force_upload (SeafileSyncTask* self);
void seafile_sync_task_set_force_upload (SeafileSyncTask* self, gboolean value);
const gchar* seafile_sync_task_get_dest_id (SeafileSyncTask* self);
void seafile_sync_task_set_dest_id (SeafileSyncTask* self, const gchar* value);
const gchar* seafile_sync_task_get_repo_id (SeafileSyncTask* self);
void seafile_sync_task_set_repo_id (SeafileSyncTask* self, const gchar* value);
const gchar* seafile_sync_task_get_state (SeafileSyncTask* self);
void seafile_sync_task_set_state (SeafileSyncTask* self, const gchar* value);
const gchar* seafile_sync_task_get_error (SeafileSyncTask* self);
void seafile_sync_task_set_error (SeafileSyncTask* self, const gchar* value);
const gchar* seafile_sync_task_get_tx_id (SeafileSyncTask* self);
void seafile_sync_task_set_tx_id (SeafileSyncTask* self, const gchar* value);
static void seafile_sync_task_finalize (GObject* obj);
static void _vala_seafile_sync_task_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_sync_task_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_session_info_get_type (void) G_GNUC_CONST;
#define SEAFILE_SESSION_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfoPrivate))
enum  {
	SEAFILE_SESSION_INFO_DUMMY_PROPERTY,
	SEAFILE_SESSION_INFO_DATADIR
};
SeafileSessionInfo* seafile_session_info_new (void);
SeafileSessionInfo* seafile_session_info_construct (GType object_type);
const gchar* seafile_session_info_get_datadir (SeafileSessionInfo* self);
void seafile_session_info_set_datadir (SeafileSessionInfo* self, const gchar* value);
static void seafile_session_info_finalize (GObject* obj);
static void _vala_seafile_session_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_session_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_checkout_task_get_type (void) G_GNUC_CONST;
#define SEAFILE_CHECKOUT_TASK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTaskPrivate))
enum  {
	SEAFILE_CHECKOUT_TASK_DUMMY_PROPERTY,
	SEAFILE_CHECKOUT_TASK_REPO_ID,
	SEAFILE_CHECKOUT_TASK_WORKTREE,
	SEAFILE_CHECKOUT_TASK_TOTAL_FILES,
	SEAFILE_CHECKOUT_TASK_FINISHED_FILES
};
SeafileCheckoutTask* seafile_checkout_task_new (void);
SeafileCheckoutTask* seafile_checkout_task_construct (GType object_type);
const gchar* seafile_checkout_task_get_repo_id (SeafileCheckoutTask* self);
void seafile_checkout_task_set_repo_id (SeafileCheckoutTask* self, const gchar* value);
const gchar* seafile_checkout_task_get_worktree (SeafileCheckoutTask* self);
void seafile_checkout_task_set_worktree (SeafileCheckoutTask* self, const gchar* value);
gint seafile_checkout_task_get_total_files (SeafileCheckoutTask* self);
void seafile_checkout_task_set_total_files (SeafileCheckoutTask* self, gint value);
gint seafile_checkout_task_get_finished_files (SeafileCheckoutTask* self);
void seafile_checkout_task_set_finished_files (SeafileCheckoutTask* self, gint value);
static void seafile_checkout_task_finalize (GObject* obj);
static void _vala_seafile_checkout_task_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_checkout_task_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_diff_entry_get_type (void) G_GNUC_CONST;
#define SEAFILE_DIFF_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntryPrivate))
enum  {
	SEAFILE_DIFF_ENTRY_DUMMY_PROPERTY,
	SEAFILE_DIFF_ENTRY_STATUS,
	SEAFILE_DIFF_ENTRY_NAME,
	SEAFILE_DIFF_ENTRY_NEW_NAME
};
SeafileDiffEntry* seafile_diff_entry_new (void);
SeafileDiffEntry* seafile_diff_entry_construct (GType object_type);
const gchar* seafile_diff_entry_get_status (SeafileDiffEntry* self);
void seafile_diff_entry_set_status (SeafileDiffEntry* self, const gchar* value);
const gchar* seafile_diff_entry_get_name (SeafileDiffEntry* self);
void seafile_diff_entry_set_name (SeafileDiffEntry* self, const gchar* value);
const gchar* seafile_diff_entry_get_new_name (SeafileDiffEntry* self);
void seafile_diff_entry_set_new_name (SeafileDiffEntry* self, const gchar* value);
static void seafile_diff_entry_finalize (GObject* obj);
static void _vala_seafile_diff_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_diff_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_deleted_entry_get_type (void) G_GNUC_CONST;
#define SEAFILE_DELETED_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntryPrivate))
enum  {
	SEAFILE_DELETED_ENTRY_DUMMY_PROPERTY,
	SEAFILE_DELETED_ENTRY_COMMIT_ID,
	SEAFILE_DELETED_ENTRY_OBJ_ID,
	SEAFILE_DELETED_ENTRY_OBJ_NAME,
	SEAFILE_DELETED_ENTRY_BASEDIR,
	SEAFILE_DELETED_ENTRY_MODE,
	SEAFILE_DELETED_ENTRY_DELETE_TIME,
	SEAFILE_DELETED_ENTRY_FILE_SIZE,
	SEAFILE_DELETED_ENTRY_SCAN_STAT
};
SeafileDeletedEntry* seafile_deleted_entry_new (void);
SeafileDeletedEntry* seafile_deleted_entry_construct (GType object_type);
const gchar* seafile_deleted_entry_get_commit_id (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_commit_id (SeafileDeletedEntry* self, const gchar* value);
const gchar* seafile_deleted_entry_get_obj_id (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_obj_id (SeafileDeletedEntry* self, const gchar* value);
const gchar* seafile_deleted_entry_get_obj_name (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_obj_name (SeafileDeletedEntry* self, const gchar* value);
const gchar* seafile_deleted_entry_get_basedir (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_basedir (SeafileDeletedEntry* self, const gchar* value);
gint seafile_deleted_entry_get_mode (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_mode (SeafileDeletedEntry* self, gint value);
gint seafile_deleted_entry_get_delete_time (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_delete_time (SeafileDeletedEntry* self, gint value);
gint64 seafile_deleted_entry_get_file_size (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_file_size (SeafileDeletedEntry* self, gint64 value);
const gchar* seafile_deleted_entry_get_scan_stat (SeafileDeletedEntry* self);
void seafile_deleted_entry_set_scan_stat (SeafileDeletedEntry* self, const gchar* value);
static void seafile_deleted_entry_finalize (GObject* obj);
static void _vala_seafile_deleted_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_deleted_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_repo_token_info_get_type (void) G_GNUC_CONST;
#define SEAFILE_REPO_TOKEN_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfoPrivate))
enum  {
	SEAFILE_REPO_TOKEN_INFO_DUMMY_PROPERTY,
	SEAFILE_REPO_TOKEN_INFO_REPO_ID,
	SEAFILE_REPO_TOKEN_INFO_REPO_NAME,
	SEAFILE_REPO_TOKEN_INFO_REPO_OWNER,
	SEAFILE_REPO_TOKEN_INFO_EMAIL,
	SEAFILE_REPO_TOKEN_INFO_TOKEN,
	SEAFILE_REPO_TOKEN_INFO_PEER_ID,
	SEAFILE_REPO_TOKEN_INFO_PEER_IP,
	SEAFILE_REPO_TOKEN_INFO_PEER_NAME,
	SEAFILE_REPO_TOKEN_INFO_SYNC_TIME,
	SEAFILE_REPO_TOKEN_INFO_CLIENT_VER
};
SeafileRepoTokenInfo* seafile_repo_token_info_new (void);
SeafileRepoTokenInfo* seafile_repo_token_info_construct (GType object_type);
const gchar* seafile_repo_token_info_get_repo_id (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_repo_id (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_repo_name (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_repo_name (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_repo_owner (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_repo_owner (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_email (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_email (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_token (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_token (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_peer_id (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_peer_id (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_peer_ip (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_peer_ip (SeafileRepoTokenInfo* self, const gchar* value);
const gchar* seafile_repo_token_info_get_peer_name (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_peer_name (SeafileRepoTokenInfo* self, const gchar* value);
gint64 seafile_repo_token_info_get_sync_time (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_sync_time (SeafileRepoTokenInfo* self, gint64 value);
const gchar* seafile_repo_token_info_get_client_ver (SeafileRepoTokenInfo* self);
void seafile_repo_token_info_set_client_ver (SeafileRepoTokenInfo* self, const gchar* value);
static void seafile_repo_token_info_finalize (GObject* obj);
static void _vala_seafile_repo_token_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_repo_token_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_shared_user_get_type (void) G_GNUC_CONST;
#define SEAFILE_SHARED_USER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_SHARED_USER, SeafileSharedUserPrivate))
enum  {
	SEAFILE_SHARED_USER_DUMMY_PROPERTY,
	SEAFILE_SHARED_USER_REPO_ID,
	SEAFILE_SHARED_USER_USER,
	SEAFILE_SHARED_USER_PERM
};
SeafileSharedUser* seafile_shared_user_new (void);
SeafileSharedUser* seafile_shared_user_construct (GType object_type);
const gchar* seafile_shared_user_get_repo_id (SeafileSharedUser* self);
void seafile_shared_user_set_repo_id (SeafileSharedUser* self, const gchar* value);
const gchar* seafile_shared_user_get_user (SeafileSharedUser* self);
void seafile_shared_user_set_user (SeafileSharedUser* self, const gchar* value);
const gchar* seafile_shared_user_get_perm (SeafileSharedUser* self);
void seafile_shared_user_set_perm (SeafileSharedUser* self, const gchar* value);
static void seafile_shared_user_finalize (GObject* obj);
static void _vala_seafile_shared_user_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_shared_user_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_shared_group_get_type (void) G_GNUC_CONST;
#define SEAFILE_SHARED_GROUP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroupPrivate))
enum  {
	SEAFILE_SHARED_GROUP_DUMMY_PROPERTY,
	SEAFILE_SHARED_GROUP_REPO_ID,
	SEAFILE_SHARED_GROUP_GROUP_ID,
	SEAFILE_SHARED_GROUP_PERM
};
SeafileSharedGroup* seafile_shared_group_new (void);
SeafileSharedGroup* seafile_shared_group_construct (GType object_type);
const gchar* seafile_shared_group_get_repo_id (SeafileSharedGroup* self);
void seafile_shared_group_set_repo_id (SeafileSharedGroup* self, const gchar* value);
gint seafile_shared_group_get_group_id (SeafileSharedGroup* self);
void seafile_shared_group_set_group_id (SeafileSharedGroup* self, gint value);
const gchar* seafile_shared_group_get_perm (SeafileSharedGroup* self);
void seafile_shared_group_set_perm (SeafileSharedGroup* self, const gchar* value);
static void seafile_shared_group_finalize (GObject* obj);
static void _vala_seafile_shared_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_shared_group_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType seafile_encryption_info_get_type (void) G_GNUC_CONST;
#define SEAFILE_ENCRYPTION_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfoPrivate))
enum  {
	SEAFILE_ENCRYPTION_INFO_DUMMY_PROPERTY,
	SEAFILE_ENCRYPTION_INFO_REPO_ID,
	SEAFILE_ENCRYPTION_INFO_PASSWD,
	SEAFILE_ENCRYPTION_INFO_ENC_VERSION,
	SEAFILE_ENCRYPTION_INFO_MAGIC,
	SEAFILE_ENCRYPTION_INFO_RANDOM_KEY
};
SeafileEncryptionInfo* seafile_encryption_info_new (void);
SeafileEncryptionInfo* seafile_encryption_info_construct (GType object_type);
const gchar* seafile_encryption_info_get_repo_id (SeafileEncryptionInfo* self);
void seafile_encryption_info_set_repo_id (SeafileEncryptionInfo* self, const gchar* value);
const gchar* seafile_encryption_info_get_passwd (SeafileEncryptionInfo* self);
void seafile_encryption_info_set_passwd (SeafileEncryptionInfo* self, const gchar* value);
gint seafile_encryption_info_get_enc_version (SeafileEncryptionInfo* self);
void seafile_encryption_info_set_enc_version (SeafileEncryptionInfo* self, gint value);
const gchar* seafile_encryption_info_get_magic (SeafileEncryptionInfo* self);
void seafile_encryption_info_set_magic (SeafileEncryptionInfo* self, const gchar* value);
const gchar* seafile_encryption_info_get_random_key (SeafileEncryptionInfo* self);
void seafile_encryption_info_set_random_key (SeafileEncryptionInfo* self, const gchar* value);
static void seafile_encryption_info_finalize (GObject* obj);
static void _vala_seafile_encryption_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_seafile_encryption_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


SeafileRepo* seafile_repo_construct (GType object_type) {
	SeafileRepo * self = NULL;
	self = (SeafileRepo*) g_object_new (object_type, NULL);
	return self;
}


SeafileRepo* seafile_repo_new (void) {
	return seafile_repo_construct (SEAFILE_TYPE_REPO);
}


const gchar* seafile_repo_get_id (SeafileRepo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (const gchar*) self->_id;
	return result;
}


void seafile_repo_set_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar _tmp1_ = '\0';
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	memcpy (self->_id, _tmp0_, (gsize) 36);
	self->_id[36] = '\0';
	_tmp1_ = self->_id[36];
	g_object_notify ((GObject *) self, "id");
}


const gchar* seafile_repo_get_name (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_name;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_name (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->_name);
	self->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


const gchar* seafile_repo_get_desc (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_desc;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_desc (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->_desc);
	self->_desc = _tmp1_;
	g_object_notify ((GObject *) self, "desc");
}


gint seafile_repo_get_version (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_version;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_version (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_version = _tmp0_;
	g_object_notify ((GObject *) self, "version");
}


gint seafile_repo_get_last_modify (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_last_modify;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_last_modify (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_last_modify = _tmp0_;
	g_object_notify ((GObject *) self, "last-modify");
}


gint64 seafile_repo_get_size (SeafileRepo* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_size;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_size (SeafileRepo* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_size = _tmp0_;
	g_object_notify ((GObject *) self, "size");
}


gint64 seafile_repo_get_file_count (SeafileRepo* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_file_count;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_file_count (SeafileRepo* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_file_count = _tmp0_;
	g_object_notify ((GObject *) self, "file-count");
}


const gchar* seafile_repo_get_head_cmmt_id (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_head_cmmt_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_head_cmmt_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_head_cmmt_id);
	self->priv->_head_cmmt_id = _tmp1_;
	g_object_notify ((GObject *) self, "head-cmmt-id");
}


const gchar* seafile_repo_get_root (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_root;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_root (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_root);
	self->priv->_root = _tmp1_;
	g_object_notify ((GObject *) self, "root");
}


const gchar* seafile_repo_get_repo_id (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_repo_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_repo_get_repo_name (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_name;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_repo_name (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_name);
	self->priv->_repo_name = _tmp1_;
	g_object_notify ((GObject *) self, "repo-name");
}


const gchar* seafile_repo_get_repo_desc (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_desc;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_repo_desc (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_desc);
	self->priv->_repo_desc = _tmp1_;
	g_object_notify ((GObject *) self, "repo-desc");
}


gint seafile_repo_get_last_modified (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_last_modified;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_last_modified (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_last_modified = _tmp0_;
	g_object_notify ((GObject *) self, "last-modified");
}


gboolean seafile_repo_get_encrypted (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_encrypted;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_encrypted (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_encrypted = _tmp0_;
	g_object_notify ((GObject *) self, "encrypted");
}


const gchar* seafile_repo_get_magic (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_magic;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_magic (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_magic);
	self->priv->_magic = _tmp1_;
	g_object_notify ((GObject *) self, "magic");
}


gint seafile_repo_get_enc_version (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_enc_version;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_enc_version (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_enc_version = _tmp0_;
	g_object_notify ((GObject *) self, "enc-version");
}


const gchar* seafile_repo_get_random_key (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_random_key;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_random_key (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_random_key);
	self->priv->_random_key = _tmp1_;
	g_object_notify ((GObject *) self, "random-key");
}


const gchar* seafile_repo_get_worktree (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_worktree;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_worktree (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->_worktree);
	self->_worktree = _tmp1_;
	g_object_notify ((GObject *) self, "worktree");
}


const gchar* seafile_repo_get_relay_id (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_relay_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_relay_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->_relay_id);
	self->_relay_id = _tmp1_;
	g_object_notify ((GObject *) self, "relay-id");
}


gint seafile_repo_get_last_sync_time (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_last_sync_time;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_last_sync_time (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_last_sync_time = _tmp0_;
	g_object_notify ((GObject *) self, "last-sync-time");
}


gboolean seafile_repo_get_auto_sync (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_auto_sync;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_auto_sync (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_auto_sync = _tmp0_;
	g_object_notify ((GObject *) self, "auto-sync");
}


gboolean seafile_repo_get_worktree_invalid (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_worktree_invalid;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_worktree_invalid (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_worktree_invalid = _tmp0_;
	g_object_notify ((GObject *) self, "worktree-invalid");
}


gboolean seafile_repo_get_is_virtual (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_virtual;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_is_virtual (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_virtual = _tmp0_;
	g_object_notify ((GObject *) self, "is-virtual");
}


const gchar* seafile_repo_get_origin_repo_id (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_origin_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_origin_repo_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_origin_repo_id);
	self->priv->_origin_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "origin-repo-id");
}


const gchar* seafile_repo_get_origin_repo_name (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_origin_repo_name;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_origin_repo_name (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_origin_repo_name);
	self->priv->_origin_repo_name = _tmp1_;
	g_object_notify ((GObject *) self, "origin-repo-name");
}


const gchar* seafile_repo_get_origin_path (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_origin_path;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_origin_path (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_origin_path);
	self->priv->_origin_path = _tmp1_;
	g_object_notify ((GObject *) self, "origin-path");
}


gboolean seafile_repo_get_is_original_owner (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_original_owner;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_is_original_owner (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_original_owner = _tmp0_;
	g_object_notify ((GObject *) self, "is-original-owner");
}


const gchar* seafile_repo_get_virtual_perm (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_virtual_perm;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_virtual_perm (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_virtual_perm);
	self->priv->_virtual_perm = _tmp1_;
	g_object_notify ((GObject *) self, "virtual-perm");
}


const gchar* seafile_repo_get_store_id (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_store_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_store_id (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_store_id);
	self->priv->_store_id = _tmp1_;
	g_object_notify ((GObject *) self, "store-id");
}


gboolean seafile_repo_get_is_corrupted (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_corrupted;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_is_corrupted (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_corrupted = _tmp0_;
	g_object_notify ((GObject *) self, "is-corrupted");
}


gboolean seafile_repo_get_repaired (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_repaired;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_repaired (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_repaired = _tmp0_;
	g_object_notify ((GObject *) self, "repaired");
}


const gchar* seafile_repo_get_share_type (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_share_type;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_share_type (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_share_type);
	self->priv->_share_type = _tmp1_;
	g_object_notify ((GObject *) self, "share-type");
}


const gchar* seafile_repo_get_permission (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_permission;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_permission (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_permission);
	self->priv->_permission = _tmp1_;
	g_object_notify ((GObject *) self, "permission");
}


const gchar* seafile_repo_get_user (SeafileRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_user (SeafileRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_user);
	self->priv->_user = _tmp1_;
	g_object_notify ((GObject *) self, "user");
}


gint seafile_repo_get_group_id (SeafileRepo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_group_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_group_id (SeafileRepo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_group_id = _tmp0_;
	g_object_notify ((GObject *) self, "group-id");
}


gboolean seafile_repo_get_is_shared (SeafileRepo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_shared;
	result = _tmp0_;
	return result;
}


void seafile_repo_set_is_shared (SeafileRepo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_shared = _tmp0_;
	g_object_notify ((GObject *) self, "is-shared");
}


static void seafile_repo_class_init (SeafileRepoClass * klass) {
	seafile_repo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileRepoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_repo_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_repo_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_repo_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ID, g_param_spec_string ("id", "id", "id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_DESC, g_param_spec_string ("desc", "desc", "desc", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_VERSION, g_param_spec_int ("version", "version", "version", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_LAST_MODIFY, g_param_spec_int ("last-modify", "last-modify", "last-modify", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_SIZE, g_param_spec_int64 ("size", "size", "size", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_FILE_COUNT, g_param_spec_int64 ("file-count", "file-count", "file-count", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_HEAD_CMMT_ID, g_param_spec_string ("head-cmmt-id", "head-cmmt-id", "head-cmmt-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ROOT, g_param_spec_string ("root", "root", "root", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_REPO_NAME, g_param_spec_string ("repo-name", "repo-name", "repo-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_REPO_DESC, g_param_spec_string ("repo-desc", "repo-desc", "repo-desc", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_LAST_MODIFIED, g_param_spec_int ("last-modified", "last-modified", "last-modified", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ENCRYPTED, g_param_spec_boolean ("encrypted", "encrypted", "encrypted", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_MAGIC, g_param_spec_string ("magic", "magic", "magic", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ENC_VERSION, g_param_spec_int ("enc-version", "enc-version", "enc-version", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_RANDOM_KEY, g_param_spec_string ("random-key", "random-key", "random-key", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_WORKTREE, g_param_spec_string ("worktree", "worktree", "worktree", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_RELAY_ID, g_param_spec_string ("relay-id", "relay-id", "relay-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_LAST_SYNC_TIME, g_param_spec_int ("last-sync-time", "last-sync-time", "last-sync-time", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_AUTO_SYNC, g_param_spec_boolean ("auto-sync", "auto-sync", "auto-sync", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_WORKTREE_INVALID, g_param_spec_boolean ("worktree-invalid", "worktree-invalid", "worktree-invalid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_IS_VIRTUAL, g_param_spec_boolean ("is-virtual", "is-virtual", "is-virtual", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ORIGIN_REPO_ID, g_param_spec_string ("origin-repo-id", "origin-repo-id", "origin-repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ORIGIN_REPO_NAME, g_param_spec_string ("origin-repo-name", "origin-repo-name", "origin-repo-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_ORIGIN_PATH, g_param_spec_string ("origin-path", "origin-path", "origin-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_IS_ORIGINAL_OWNER, g_param_spec_boolean ("is-original-owner", "is-original-owner", "is-original-owner", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_VIRTUAL_PERM, g_param_spec_string ("virtual-perm", "virtual-perm", "virtual-perm", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_STORE_ID, g_param_spec_string ("store-id", "store-id", "store-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_IS_CORRUPTED, g_param_spec_boolean ("is-corrupted", "is-corrupted", "is-corrupted", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_REPAIRED, g_param_spec_boolean ("repaired", "repaired", "repaired", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_SHARE_TYPE, g_param_spec_string ("share-type", "share-type", "share-type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_PERMISSION, g_param_spec_string ("permission", "permission", "permission", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_USER, g_param_spec_string ("user", "user", "user", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_GROUP_ID, g_param_spec_int ("group-id", "group-id", "group-id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_IS_SHARED, g_param_spec_boolean ("is-shared", "is-shared", "is-shared", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_repo_instance_init (SeafileRepo * self) {
	self->priv = SEAFILE_REPO_GET_PRIVATE (self);
}


static void seafile_repo_finalize (GObject* obj) {
	SeafileRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_REPO, SeafileRepo);
	_g_free0 (self->_name);
	_g_free0 (self->_desc);
	_g_free0 (self->priv->_head_cmmt_id);
	_g_free0 (self->priv->_root);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_repo_name);
	_g_free0 (self->priv->_repo_desc);
	_g_free0 (self->priv->_magic);
	_g_free0 (self->priv->_random_key);
	_g_free0 (self->_worktree);
	_g_free0 (self->_relay_id);
	_g_free0 (self->priv->_origin_repo_id);
	_g_free0 (self->priv->_origin_repo_name);
	_g_free0 (self->priv->_origin_path);
	_g_free0 (self->priv->_virtual_perm);
	_g_free0 (self->priv->_store_id);
	_g_free0 (self->priv->_share_type);
	_g_free0 (self->priv->_permission);
	_g_free0 (self->priv->_user);
	G_OBJECT_CLASS (seafile_repo_parent_class)->finalize (obj);
}


GType seafile_repo_get_type (void) {
	static volatile gsize seafile_repo_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_repo_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileRepoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_repo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileRepo), 0, (GInstanceInitFunc) seafile_repo_instance_init, NULL };
		GType seafile_repo_type_id;
		seafile_repo_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileRepo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_repo_type_id__volatile, seafile_repo_type_id);
	}
	return seafile_repo_type_id__volatile;
}


static void _vala_seafile_repo_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_REPO, SeafileRepo);
	switch (property_id) {
		case SEAFILE_REPO_ID:
		g_value_set_string (value, seafile_repo_get_id (self));
		break;
		case SEAFILE_REPO_NAME:
		g_value_set_string (value, seafile_repo_get_name (self));
		break;
		case SEAFILE_REPO_DESC:
		g_value_set_string (value, seafile_repo_get_desc (self));
		break;
		case SEAFILE_REPO_VERSION:
		g_value_set_int (value, seafile_repo_get_version (self));
		break;
		case SEAFILE_REPO_LAST_MODIFY:
		g_value_set_int (value, seafile_repo_get_last_modify (self));
		break;
		case SEAFILE_REPO_SIZE:
		g_value_set_int64 (value, seafile_repo_get_size (self));
		break;
		case SEAFILE_REPO_FILE_COUNT:
		g_value_set_int64 (value, seafile_repo_get_file_count (self));
		break;
		case SEAFILE_REPO_HEAD_CMMT_ID:
		g_value_set_string (value, seafile_repo_get_head_cmmt_id (self));
		break;
		case SEAFILE_REPO_ROOT:
		g_value_set_string (value, seafile_repo_get_root (self));
		break;
		case SEAFILE_REPO_REPO_ID:
		g_value_set_string (value, seafile_repo_get_repo_id (self));
		break;
		case SEAFILE_REPO_REPO_NAME:
		g_value_set_string (value, seafile_repo_get_repo_name (self));
		break;
		case SEAFILE_REPO_REPO_DESC:
		g_value_set_string (value, seafile_repo_get_repo_desc (self));
		break;
		case SEAFILE_REPO_LAST_MODIFIED:
		g_value_set_int (value, seafile_repo_get_last_modified (self));
		break;
		case SEAFILE_REPO_ENCRYPTED:
		g_value_set_boolean (value, seafile_repo_get_encrypted (self));
		break;
		case SEAFILE_REPO_MAGIC:
		g_value_set_string (value, seafile_repo_get_magic (self));
		break;
		case SEAFILE_REPO_ENC_VERSION:
		g_value_set_int (value, seafile_repo_get_enc_version (self));
		break;
		case SEAFILE_REPO_RANDOM_KEY:
		g_value_set_string (value, seafile_repo_get_random_key (self));
		break;
		case SEAFILE_REPO_WORKTREE:
		g_value_set_string (value, seafile_repo_get_worktree (self));
		break;
		case SEAFILE_REPO_RELAY_ID:
		g_value_set_string (value, seafile_repo_get_relay_id (self));
		break;
		case SEAFILE_REPO_LAST_SYNC_TIME:
		g_value_set_int (value, seafile_repo_get_last_sync_time (self));
		break;
		case SEAFILE_REPO_AUTO_SYNC:
		g_value_set_boolean (value, seafile_repo_get_auto_sync (self));
		break;
		case SEAFILE_REPO_WORKTREE_INVALID:
		g_value_set_boolean (value, seafile_repo_get_worktree_invalid (self));
		break;
		case SEAFILE_REPO_IS_VIRTUAL:
		g_value_set_boolean (value, seafile_repo_get_is_virtual (self));
		break;
		case SEAFILE_REPO_ORIGIN_REPO_ID:
		g_value_set_string (value, seafile_repo_get_origin_repo_id (self));
		break;
		case SEAFILE_REPO_ORIGIN_REPO_NAME:
		g_value_set_string (value, seafile_repo_get_origin_repo_name (self));
		break;
		case SEAFILE_REPO_ORIGIN_PATH:
		g_value_set_string (value, seafile_repo_get_origin_path (self));
		break;
		case SEAFILE_REPO_IS_ORIGINAL_OWNER:
		g_value_set_boolean (value, seafile_repo_get_is_original_owner (self));
		break;
		case SEAFILE_REPO_VIRTUAL_PERM:
		g_value_set_string (value, seafile_repo_get_virtual_perm (self));
		break;
		case SEAFILE_REPO_STORE_ID:
		g_value_set_string (value, seafile_repo_get_store_id (self));
		break;
		case SEAFILE_REPO_IS_CORRUPTED:
		g_value_set_boolean (value, seafile_repo_get_is_corrupted (self));
		break;
		case SEAFILE_REPO_REPAIRED:
		g_value_set_boolean (value, seafile_repo_get_repaired (self));
		break;
		case SEAFILE_REPO_SHARE_TYPE:
		g_value_set_string (value, seafile_repo_get_share_type (self));
		break;
		case SEAFILE_REPO_PERMISSION:
		g_value_set_string (value, seafile_repo_get_permission (self));
		break;
		case SEAFILE_REPO_USER:
		g_value_set_string (value, seafile_repo_get_user (self));
		break;
		case SEAFILE_REPO_GROUP_ID:
		g_value_set_int (value, seafile_repo_get_group_id (self));
		break;
		case SEAFILE_REPO_IS_SHARED:
		g_value_set_boolean (value, seafile_repo_get_is_shared (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_repo_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_REPO, SeafileRepo);
	switch (property_id) {
		case SEAFILE_REPO_ID:
		seafile_repo_set_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_NAME:
		seafile_repo_set_name (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_DESC:
		seafile_repo_set_desc (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_VERSION:
		seafile_repo_set_version (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_LAST_MODIFY:
		seafile_repo_set_last_modify (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_SIZE:
		seafile_repo_set_size (self, g_value_get_int64 (value));
		break;
		case SEAFILE_REPO_FILE_COUNT:
		seafile_repo_set_file_count (self, g_value_get_int64 (value));
		break;
		case SEAFILE_REPO_HEAD_CMMT_ID:
		seafile_repo_set_head_cmmt_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_ROOT:
		seafile_repo_set_root (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_REPO_ID:
		seafile_repo_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_REPO_NAME:
		seafile_repo_set_repo_name (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_REPO_DESC:
		seafile_repo_set_repo_desc (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_LAST_MODIFIED:
		seafile_repo_set_last_modified (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_ENCRYPTED:
		seafile_repo_set_encrypted (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_MAGIC:
		seafile_repo_set_magic (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_ENC_VERSION:
		seafile_repo_set_enc_version (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_RANDOM_KEY:
		seafile_repo_set_random_key (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_WORKTREE:
		seafile_repo_set_worktree (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_RELAY_ID:
		seafile_repo_set_relay_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_LAST_SYNC_TIME:
		seafile_repo_set_last_sync_time (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_AUTO_SYNC:
		seafile_repo_set_auto_sync (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_WORKTREE_INVALID:
		seafile_repo_set_worktree_invalid (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_IS_VIRTUAL:
		seafile_repo_set_is_virtual (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_ORIGIN_REPO_ID:
		seafile_repo_set_origin_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_ORIGIN_REPO_NAME:
		seafile_repo_set_origin_repo_name (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_ORIGIN_PATH:
		seafile_repo_set_origin_path (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_IS_ORIGINAL_OWNER:
		seafile_repo_set_is_original_owner (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_VIRTUAL_PERM:
		seafile_repo_set_virtual_perm (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_STORE_ID:
		seafile_repo_set_store_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_IS_CORRUPTED:
		seafile_repo_set_is_corrupted (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_REPAIRED:
		seafile_repo_set_repaired (self, g_value_get_boolean (value));
		break;
		case SEAFILE_REPO_SHARE_TYPE:
		seafile_repo_set_share_type (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_PERMISSION:
		seafile_repo_set_permission (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_USER:
		seafile_repo_set_user (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_GROUP_ID:
		seafile_repo_set_group_id (self, g_value_get_int (value));
		break;
		case SEAFILE_REPO_IS_SHARED:
		seafile_repo_set_is_shared (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileTrashRepo* seafile_trash_repo_construct (GType object_type) {
	SeafileTrashRepo * self = NULL;
	self = (SeafileTrashRepo*) g_object_new (object_type, NULL);
	return self;
}


SeafileTrashRepo* seafile_trash_repo_new (void) {
	return seafile_trash_repo_construct (SEAFILE_TYPE_TRASH_REPO);
}


const gchar* seafile_trash_repo_get_repo_id (SeafileTrashRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_repo_id (SeafileTrashRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_trash_repo_get_repo_name (SeafileTrashRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_name;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_repo_name (SeafileTrashRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_name);
	self->priv->_repo_name = _tmp1_;
	g_object_notify ((GObject *) self, "repo-name");
}


const gchar* seafile_trash_repo_get_head_id (SeafileTrashRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_head_id;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_head_id (SeafileTrashRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_head_id);
	self->priv->_head_id = _tmp1_;
	g_object_notify ((GObject *) self, "head-id");
}


const gchar* seafile_trash_repo_get_owner_id (SeafileTrashRepo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_owner_id;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_owner_id (SeafileTrashRepo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_owner_id);
	self->priv->_owner_id = _tmp1_;
	g_object_notify ((GObject *) self, "owner-id");
}


gint64 seafile_trash_repo_get_size (SeafileTrashRepo* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_size;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_size (SeafileTrashRepo* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_size = _tmp0_;
	g_object_notify ((GObject *) self, "size");
}


gint64 seafile_trash_repo_get_del_time (SeafileTrashRepo* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_del_time;
	result = _tmp0_;
	return result;
}


void seafile_trash_repo_set_del_time (SeafileTrashRepo* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_del_time = _tmp0_;
	g_object_notify ((GObject *) self, "del-time");
}


static void seafile_trash_repo_class_init (SeafileTrashRepoClass * klass) {
	seafile_trash_repo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileTrashRepoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_trash_repo_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_trash_repo_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_trash_repo_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_REPO_NAME, g_param_spec_string ("repo-name", "repo-name", "repo-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_HEAD_ID, g_param_spec_string ("head-id", "head-id", "head-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_OWNER_ID, g_param_spec_string ("owner-id", "owner-id", "owner-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_SIZE, g_param_spec_int64 ("size", "size", "size", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TRASH_REPO_DEL_TIME, g_param_spec_int64 ("del-time", "del-time", "del-time", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_trash_repo_instance_init (SeafileTrashRepo * self) {
	self->priv = SEAFILE_TRASH_REPO_GET_PRIVATE (self);
}


static void seafile_trash_repo_finalize (GObject* obj) {
	SeafileTrashRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepo);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_repo_name);
	_g_free0 (self->priv->_head_id);
	_g_free0 (self->priv->_owner_id);
	G_OBJECT_CLASS (seafile_trash_repo_parent_class)->finalize (obj);
}


GType seafile_trash_repo_get_type (void) {
	static volatile gsize seafile_trash_repo_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_trash_repo_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileTrashRepoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_trash_repo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileTrashRepo), 0, (GInstanceInitFunc) seafile_trash_repo_instance_init, NULL };
		GType seafile_trash_repo_type_id;
		seafile_trash_repo_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileTrashRepo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_trash_repo_type_id__volatile, seafile_trash_repo_type_id);
	}
	return seafile_trash_repo_type_id__volatile;
}


static void _vala_seafile_trash_repo_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileTrashRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepo);
	switch (property_id) {
		case SEAFILE_TRASH_REPO_REPO_ID:
		g_value_set_string (value, seafile_trash_repo_get_repo_id (self));
		break;
		case SEAFILE_TRASH_REPO_REPO_NAME:
		g_value_set_string (value, seafile_trash_repo_get_repo_name (self));
		break;
		case SEAFILE_TRASH_REPO_HEAD_ID:
		g_value_set_string (value, seafile_trash_repo_get_head_id (self));
		break;
		case SEAFILE_TRASH_REPO_OWNER_ID:
		g_value_set_string (value, seafile_trash_repo_get_owner_id (self));
		break;
		case SEAFILE_TRASH_REPO_SIZE:
		g_value_set_int64 (value, seafile_trash_repo_get_size (self));
		break;
		case SEAFILE_TRASH_REPO_DEL_TIME:
		g_value_set_int64 (value, seafile_trash_repo_get_del_time (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_trash_repo_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileTrashRepo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_TRASH_REPO, SeafileTrashRepo);
	switch (property_id) {
		case SEAFILE_TRASH_REPO_REPO_ID:
		seafile_trash_repo_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_TRASH_REPO_REPO_NAME:
		seafile_trash_repo_set_repo_name (self, g_value_get_string (value));
		break;
		case SEAFILE_TRASH_REPO_HEAD_ID:
		seafile_trash_repo_set_head_id (self, g_value_get_string (value));
		break;
		case SEAFILE_TRASH_REPO_OWNER_ID:
		seafile_trash_repo_set_owner_id (self, g_value_get_string (value));
		break;
		case SEAFILE_TRASH_REPO_SIZE:
		seafile_trash_repo_set_size (self, g_value_get_int64 (value));
		break;
		case SEAFILE_TRASH_REPO_DEL_TIME:
		seafile_trash_repo_set_del_time (self, g_value_get_int64 (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileSyncInfo* seafile_sync_info_construct (GType object_type) {
	SeafileSyncInfo * self = NULL;
	self = (SeafileSyncInfo*) g_object_new (object_type, NULL);
	return self;
}


SeafileSyncInfo* seafile_sync_info_new (void) {
	return seafile_sync_info_construct (SEAFILE_TYPE_SYNC_INFO);
}


const gchar* seafile_sync_info_get_repo_id (SeafileSyncInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_repo_id (SeafileSyncInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_sync_info_get_head_commit (SeafileSyncInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_head_commit;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_head_commit (SeafileSyncInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_head_commit);
	self->priv->_head_commit = _tmp1_;
	g_object_notify ((GObject *) self, "head-commit");
}


gboolean seafile_sync_info_get_deleted_on_relay (SeafileSyncInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_deleted_on_relay;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_deleted_on_relay (SeafileSyncInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_deleted_on_relay = _tmp0_;
	g_object_notify ((GObject *) self, "deleted-on-relay");
}


gboolean seafile_sync_info_get_bad_local_branch (SeafileSyncInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_bad_local_branch;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_bad_local_branch (SeafileSyncInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_bad_local_branch = _tmp0_;
	g_object_notify ((GObject *) self, "bad-local-branch");
}


gboolean seafile_sync_info_get_need_fetch (SeafileSyncInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_need_fetch;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_need_fetch (SeafileSyncInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_need_fetch = _tmp0_;
	g_object_notify ((GObject *) self, "need-fetch");
}


gboolean seafile_sync_info_get_need_upload (SeafileSyncInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_need_upload;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_need_upload (SeafileSyncInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_need_upload = _tmp0_;
	g_object_notify ((GObject *) self, "need-upload");
}


gboolean seafile_sync_info_get_need_merge (SeafileSyncInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_need_merge;
	result = _tmp0_;
	return result;
}


void seafile_sync_info_set_need_merge (SeafileSyncInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_need_merge = _tmp0_;
	g_object_notify ((GObject *) self, "need-merge");
}


static void seafile_sync_info_class_init (SeafileSyncInfoClass * klass) {
	seafile_sync_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileSyncInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_sync_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_sync_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_sync_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_HEAD_COMMIT, g_param_spec_string ("head-commit", "head-commit", "head-commit", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_DELETED_ON_RELAY, g_param_spec_boolean ("deleted-on-relay", "deleted-on-relay", "deleted-on-relay", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_BAD_LOCAL_BRANCH, g_param_spec_boolean ("bad-local-branch", "bad-local-branch", "bad-local-branch", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_NEED_FETCH, g_param_spec_boolean ("need-fetch", "need-fetch", "need-fetch", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_NEED_UPLOAD, g_param_spec_boolean ("need-upload", "need-upload", "need-upload", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_INFO_NEED_MERGE, g_param_spec_boolean ("need-merge", "need-merge", "need-merge", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_sync_info_instance_init (SeafileSyncInfo * self) {
	self->priv = SEAFILE_SYNC_INFO_GET_PRIVATE (self);
}


static void seafile_sync_info_finalize (GObject* obj) {
	SeafileSyncInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfo);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_head_commit);
	G_OBJECT_CLASS (seafile_sync_info_parent_class)->finalize (obj);
}


GType seafile_sync_info_get_type (void) {
	static volatile gsize seafile_sync_info_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_sync_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileSyncInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_sync_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileSyncInfo), 0, (GInstanceInitFunc) seafile_sync_info_instance_init, NULL };
		GType seafile_sync_info_type_id;
		seafile_sync_info_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileSyncInfo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_sync_info_type_id__volatile, seafile_sync_info_type_id);
	}
	return seafile_sync_info_type_id__volatile;
}


static void _vala_seafile_sync_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileSyncInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfo);
	switch (property_id) {
		case SEAFILE_SYNC_INFO_REPO_ID:
		g_value_set_string (value, seafile_sync_info_get_repo_id (self));
		break;
		case SEAFILE_SYNC_INFO_HEAD_COMMIT:
		g_value_set_string (value, seafile_sync_info_get_head_commit (self));
		break;
		case SEAFILE_SYNC_INFO_DELETED_ON_RELAY:
		g_value_set_boolean (value, seafile_sync_info_get_deleted_on_relay (self));
		break;
		case SEAFILE_SYNC_INFO_BAD_LOCAL_BRANCH:
		g_value_set_boolean (value, seafile_sync_info_get_bad_local_branch (self));
		break;
		case SEAFILE_SYNC_INFO_NEED_FETCH:
		g_value_set_boolean (value, seafile_sync_info_get_need_fetch (self));
		break;
		case SEAFILE_SYNC_INFO_NEED_UPLOAD:
		g_value_set_boolean (value, seafile_sync_info_get_need_upload (self));
		break;
		case SEAFILE_SYNC_INFO_NEED_MERGE:
		g_value_set_boolean (value, seafile_sync_info_get_need_merge (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_sync_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileSyncInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SYNC_INFO, SeafileSyncInfo);
	switch (property_id) {
		case SEAFILE_SYNC_INFO_REPO_ID:
		seafile_sync_info_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_INFO_HEAD_COMMIT:
		seafile_sync_info_set_head_commit (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_INFO_DELETED_ON_RELAY:
		seafile_sync_info_set_deleted_on_relay (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_INFO_BAD_LOCAL_BRANCH:
		seafile_sync_info_set_bad_local_branch (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_INFO_NEED_FETCH:
		seafile_sync_info_set_need_fetch (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_INFO_NEED_UPLOAD:
		seafile_sync_info_set_need_upload (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_INFO_NEED_MERGE:
		seafile_sync_info_set_need_merge (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileSyncTask* seafile_sync_task_construct (GType object_type) {
	SeafileSyncTask * self = NULL;
	self = (SeafileSyncTask*) g_object_new (object_type, NULL);
	return self;
}


SeafileSyncTask* seafile_sync_task_new (void) {
	return seafile_sync_task_construct (SEAFILE_TYPE_SYNC_TASK);
}


gboolean seafile_sync_task_get_is_sync_lan (SeafileSyncTask* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_sync_lan;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_is_sync_lan (SeafileSyncTask* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_sync_lan = _tmp0_;
	g_object_notify ((GObject *) self, "is-sync-lan");
}


gboolean seafile_sync_task_get_force_upload (SeafileSyncTask* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_force_upload;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_force_upload (SeafileSyncTask* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_force_upload = _tmp0_;
	g_object_notify ((GObject *) self, "force-upload");
}


const gchar* seafile_sync_task_get_dest_id (SeafileSyncTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_dest_id;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_dest_id (SeafileSyncTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_dest_id);
	self->priv->_dest_id = _tmp1_;
	g_object_notify ((GObject *) self, "dest-id");
}


const gchar* seafile_sync_task_get_repo_id (SeafileSyncTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_repo_id (SeafileSyncTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_sync_task_get_state (SeafileSyncTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_state (SeafileSyncTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_state);
	self->priv->_state = _tmp1_;
	g_object_notify ((GObject *) self, "state");
}


const gchar* seafile_sync_task_get_error (SeafileSyncTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_error;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_error (SeafileSyncTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_error);
	self->priv->_error = _tmp1_;
	g_object_notify ((GObject *) self, "error");
}


const gchar* seafile_sync_task_get_tx_id (SeafileSyncTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_tx_id;
	result = _tmp0_;
	return result;
}


void seafile_sync_task_set_tx_id (SeafileSyncTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_tx_id);
	self->priv->_tx_id = _tmp1_;
	g_object_notify ((GObject *) self, "tx-id");
}


static void seafile_sync_task_class_init (SeafileSyncTaskClass * klass) {
	seafile_sync_task_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileSyncTaskPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_sync_task_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_sync_task_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_sync_task_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_IS_SYNC_LAN, g_param_spec_boolean ("is-sync-lan", "is-sync-lan", "is-sync-lan", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_FORCE_UPLOAD, g_param_spec_boolean ("force-upload", "force-upload", "force-upload", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_DEST_ID, g_param_spec_string ("dest-id", "dest-id", "dest-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_STATE, g_param_spec_string ("state", "state", "state", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_ERROR, g_param_spec_string ("error", "error", "error", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SYNC_TASK_TX_ID, g_param_spec_string ("tx-id", "tx-id", "tx-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_sync_task_instance_init (SeafileSyncTask * self) {
	self->priv = SEAFILE_SYNC_TASK_GET_PRIVATE (self);
}


static void seafile_sync_task_finalize (GObject* obj) {
	SeafileSyncTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_SYNC_TASK, SeafileSyncTask);
	_g_free0 (self->priv->_dest_id);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_state);
	_g_free0 (self->priv->_error);
	_g_free0 (self->priv->_tx_id);
	G_OBJECT_CLASS (seafile_sync_task_parent_class)->finalize (obj);
}


GType seafile_sync_task_get_type (void) {
	static volatile gsize seafile_sync_task_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_sync_task_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileSyncTaskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_sync_task_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileSyncTask), 0, (GInstanceInitFunc) seafile_sync_task_instance_init, NULL };
		GType seafile_sync_task_type_id;
		seafile_sync_task_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileSyncTask", &g_define_type_info, 0);
		g_once_init_leave (&seafile_sync_task_type_id__volatile, seafile_sync_task_type_id);
	}
	return seafile_sync_task_type_id__volatile;
}


static void _vala_seafile_sync_task_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileSyncTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SYNC_TASK, SeafileSyncTask);
	switch (property_id) {
		case SEAFILE_SYNC_TASK_IS_SYNC_LAN:
		g_value_set_boolean (value, seafile_sync_task_get_is_sync_lan (self));
		break;
		case SEAFILE_SYNC_TASK_FORCE_UPLOAD:
		g_value_set_boolean (value, seafile_sync_task_get_force_upload (self));
		break;
		case SEAFILE_SYNC_TASK_DEST_ID:
		g_value_set_string (value, seafile_sync_task_get_dest_id (self));
		break;
		case SEAFILE_SYNC_TASK_REPO_ID:
		g_value_set_string (value, seafile_sync_task_get_repo_id (self));
		break;
		case SEAFILE_SYNC_TASK_STATE:
		g_value_set_string (value, seafile_sync_task_get_state (self));
		break;
		case SEAFILE_SYNC_TASK_ERROR:
		g_value_set_string (value, seafile_sync_task_get_error (self));
		break;
		case SEAFILE_SYNC_TASK_TX_ID:
		g_value_set_string (value, seafile_sync_task_get_tx_id (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_sync_task_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileSyncTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SYNC_TASK, SeafileSyncTask);
	switch (property_id) {
		case SEAFILE_SYNC_TASK_IS_SYNC_LAN:
		seafile_sync_task_set_is_sync_lan (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_TASK_FORCE_UPLOAD:
		seafile_sync_task_set_force_upload (self, g_value_get_boolean (value));
		break;
		case SEAFILE_SYNC_TASK_DEST_ID:
		seafile_sync_task_set_dest_id (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_TASK_REPO_ID:
		seafile_sync_task_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_TASK_STATE:
		seafile_sync_task_set_state (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_TASK_ERROR:
		seafile_sync_task_set_error (self, g_value_get_string (value));
		break;
		case SEAFILE_SYNC_TASK_TX_ID:
		seafile_sync_task_set_tx_id (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileSessionInfo* seafile_session_info_construct (GType object_type) {
	SeafileSessionInfo * self = NULL;
	self = (SeafileSessionInfo*) g_object_new (object_type, NULL);
	return self;
}


SeafileSessionInfo* seafile_session_info_new (void) {
	return seafile_session_info_construct (SEAFILE_TYPE_SESSION_INFO);
}


const gchar* seafile_session_info_get_datadir (SeafileSessionInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_datadir;
	result = _tmp0_;
	return result;
}


void seafile_session_info_set_datadir (SeafileSessionInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_datadir);
	self->priv->_datadir = _tmp1_;
	g_object_notify ((GObject *) self, "datadir");
}


static void seafile_session_info_class_init (SeafileSessionInfoClass * klass) {
	seafile_session_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileSessionInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_session_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_session_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_session_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SESSION_INFO_DATADIR, g_param_spec_string ("datadir", "datadir", "datadir", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_session_info_instance_init (SeafileSessionInfo * self) {
	self->priv = SEAFILE_SESSION_INFO_GET_PRIVATE (self);
}


static void seafile_session_info_finalize (GObject* obj) {
	SeafileSessionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfo);
	_g_free0 (self->priv->_datadir);
	G_OBJECT_CLASS (seafile_session_info_parent_class)->finalize (obj);
}


GType seafile_session_info_get_type (void) {
	static volatile gsize seafile_session_info_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_session_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileSessionInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_session_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileSessionInfo), 0, (GInstanceInitFunc) seafile_session_info_instance_init, NULL };
		GType seafile_session_info_type_id;
		seafile_session_info_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileSessionInfo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_session_info_type_id__volatile, seafile_session_info_type_id);
	}
	return seafile_session_info_type_id__volatile;
}


static void _vala_seafile_session_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileSessionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfo);
	switch (property_id) {
		case SEAFILE_SESSION_INFO_DATADIR:
		g_value_set_string (value, seafile_session_info_get_datadir (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_session_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileSessionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SESSION_INFO, SeafileSessionInfo);
	switch (property_id) {
		case SEAFILE_SESSION_INFO_DATADIR:
		seafile_session_info_set_datadir (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileCheckoutTask* seafile_checkout_task_construct (GType object_type) {
	SeafileCheckoutTask * self = NULL;
	self = (SeafileCheckoutTask*) g_object_new (object_type, NULL);
	return self;
}


SeafileCheckoutTask* seafile_checkout_task_new (void) {
	return seafile_checkout_task_construct (SEAFILE_TYPE_CHECKOUT_TASK);
}


const gchar* seafile_checkout_task_get_repo_id (SeafileCheckoutTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_checkout_task_set_repo_id (SeafileCheckoutTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_checkout_task_get_worktree (SeafileCheckoutTask* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_worktree;
	result = _tmp0_;
	return result;
}


void seafile_checkout_task_set_worktree (SeafileCheckoutTask* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_worktree);
	self->priv->_worktree = _tmp1_;
	g_object_notify ((GObject *) self, "worktree");
}


gint seafile_checkout_task_get_total_files (SeafileCheckoutTask* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_total_files;
	result = _tmp0_;
	return result;
}


void seafile_checkout_task_set_total_files (SeafileCheckoutTask* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_total_files = _tmp0_;
	g_object_notify ((GObject *) self, "total-files");
}


gint seafile_checkout_task_get_finished_files (SeafileCheckoutTask* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_finished_files;
	result = _tmp0_;
	return result;
}


void seafile_checkout_task_set_finished_files (SeafileCheckoutTask* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_finished_files = _tmp0_;
	g_object_notify ((GObject *) self, "finished-files");
}


static void seafile_checkout_task_class_init (SeafileCheckoutTaskClass * klass) {
	seafile_checkout_task_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileCheckoutTaskPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_checkout_task_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_checkout_task_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_checkout_task_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CHECKOUT_TASK_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CHECKOUT_TASK_WORKTREE, g_param_spec_string ("worktree", "worktree", "worktree", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CHECKOUT_TASK_TOTAL_FILES, g_param_spec_int ("total-files", "total-files", "total-files", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CHECKOUT_TASK_FINISHED_FILES, g_param_spec_int ("finished-files", "finished-files", "finished-files", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_checkout_task_instance_init (SeafileCheckoutTask * self) {
	self->priv = SEAFILE_CHECKOUT_TASK_GET_PRIVATE (self);
}


static void seafile_checkout_task_finalize (GObject* obj) {
	SeafileCheckoutTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTask);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_worktree);
	G_OBJECT_CLASS (seafile_checkout_task_parent_class)->finalize (obj);
}


GType seafile_checkout_task_get_type (void) {
	static volatile gsize seafile_checkout_task_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_checkout_task_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileCheckoutTaskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_checkout_task_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileCheckoutTask), 0, (GInstanceInitFunc) seafile_checkout_task_instance_init, NULL };
		GType seafile_checkout_task_type_id;
		seafile_checkout_task_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileCheckoutTask", &g_define_type_info, 0);
		g_once_init_leave (&seafile_checkout_task_type_id__volatile, seafile_checkout_task_type_id);
	}
	return seafile_checkout_task_type_id__volatile;
}


static void _vala_seafile_checkout_task_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileCheckoutTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTask);
	switch (property_id) {
		case SEAFILE_CHECKOUT_TASK_REPO_ID:
		g_value_set_string (value, seafile_checkout_task_get_repo_id (self));
		break;
		case SEAFILE_CHECKOUT_TASK_WORKTREE:
		g_value_set_string (value, seafile_checkout_task_get_worktree (self));
		break;
		case SEAFILE_CHECKOUT_TASK_TOTAL_FILES:
		g_value_set_int (value, seafile_checkout_task_get_total_files (self));
		break;
		case SEAFILE_CHECKOUT_TASK_FINISHED_FILES:
		g_value_set_int (value, seafile_checkout_task_get_finished_files (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_checkout_task_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileCheckoutTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_CHECKOUT_TASK, SeafileCheckoutTask);
	switch (property_id) {
		case SEAFILE_CHECKOUT_TASK_REPO_ID:
		seafile_checkout_task_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_CHECKOUT_TASK_WORKTREE:
		seafile_checkout_task_set_worktree (self, g_value_get_string (value));
		break;
		case SEAFILE_CHECKOUT_TASK_TOTAL_FILES:
		seafile_checkout_task_set_total_files (self, g_value_get_int (value));
		break;
		case SEAFILE_CHECKOUT_TASK_FINISHED_FILES:
		seafile_checkout_task_set_finished_files (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileDiffEntry* seafile_diff_entry_construct (GType object_type) {
	SeafileDiffEntry * self = NULL;
	self = (SeafileDiffEntry*) g_object_new (object_type, NULL);
	return self;
}


SeafileDiffEntry* seafile_diff_entry_new (void) {
	return seafile_diff_entry_construct (SEAFILE_TYPE_DIFF_ENTRY);
}


const gchar* seafile_diff_entry_get_status (SeafileDiffEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_status;
	result = _tmp0_;
	return result;
}


void seafile_diff_entry_set_status (SeafileDiffEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_status);
	self->priv->_status = _tmp1_;
	g_object_notify ((GObject *) self, "status");
}


const gchar* seafile_diff_entry_get_name (SeafileDiffEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void seafile_diff_entry_set_name (SeafileDiffEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


const gchar* seafile_diff_entry_get_new_name (SeafileDiffEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_new_name;
	result = _tmp0_;
	return result;
}


void seafile_diff_entry_set_new_name (SeafileDiffEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_new_name);
	self->priv->_new_name = _tmp1_;
	g_object_notify ((GObject *) self, "new-name");
}


static void seafile_diff_entry_class_init (SeafileDiffEntryClass * klass) {
	seafile_diff_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileDiffEntryPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_diff_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_diff_entry_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_diff_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DIFF_ENTRY_STATUS, g_param_spec_string ("status", "status", "status", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DIFF_ENTRY_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DIFF_ENTRY_NEW_NAME, g_param_spec_string ("new-name", "new-name", "new-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_diff_entry_instance_init (SeafileDiffEntry * self) {
	self->priv = SEAFILE_DIFF_ENTRY_GET_PRIVATE (self);
}


static void seafile_diff_entry_finalize (GObject* obj) {
	SeafileDiffEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntry);
	_g_free0 (self->priv->_status);
	_g_free0 (self->priv->_name);
	_g_free0 (self->priv->_new_name);
	G_OBJECT_CLASS (seafile_diff_entry_parent_class)->finalize (obj);
}


GType seafile_diff_entry_get_type (void) {
	static volatile gsize seafile_diff_entry_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_diff_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileDiffEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_diff_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileDiffEntry), 0, (GInstanceInitFunc) seafile_diff_entry_instance_init, NULL };
		GType seafile_diff_entry_type_id;
		seafile_diff_entry_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileDiffEntry", &g_define_type_info, 0);
		g_once_init_leave (&seafile_diff_entry_type_id__volatile, seafile_diff_entry_type_id);
	}
	return seafile_diff_entry_type_id__volatile;
}


static void _vala_seafile_diff_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileDiffEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntry);
	switch (property_id) {
		case SEAFILE_DIFF_ENTRY_STATUS:
		g_value_set_string (value, seafile_diff_entry_get_status (self));
		break;
		case SEAFILE_DIFF_ENTRY_NAME:
		g_value_set_string (value, seafile_diff_entry_get_name (self));
		break;
		case SEAFILE_DIFF_ENTRY_NEW_NAME:
		g_value_set_string (value, seafile_diff_entry_get_new_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_diff_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileDiffEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_DIFF_ENTRY, SeafileDiffEntry);
	switch (property_id) {
		case SEAFILE_DIFF_ENTRY_STATUS:
		seafile_diff_entry_set_status (self, g_value_get_string (value));
		break;
		case SEAFILE_DIFF_ENTRY_NAME:
		seafile_diff_entry_set_name (self, g_value_get_string (value));
		break;
		case SEAFILE_DIFF_ENTRY_NEW_NAME:
		seafile_diff_entry_set_new_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileDeletedEntry* seafile_deleted_entry_construct (GType object_type) {
	SeafileDeletedEntry * self = NULL;
	self = (SeafileDeletedEntry*) g_object_new (object_type, NULL);
	return self;
}


SeafileDeletedEntry* seafile_deleted_entry_new (void) {
	return seafile_deleted_entry_construct (SEAFILE_TYPE_DELETED_ENTRY);
}


const gchar* seafile_deleted_entry_get_commit_id (SeafileDeletedEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_commit_id;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_commit_id (SeafileDeletedEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_commit_id);
	self->priv->_commit_id = _tmp1_;
	g_object_notify ((GObject *) self, "commit-id");
}


const gchar* seafile_deleted_entry_get_obj_id (SeafileDeletedEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_obj_id;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_obj_id (SeafileDeletedEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_obj_id);
	self->priv->_obj_id = _tmp1_;
	g_object_notify ((GObject *) self, "obj-id");
}


const gchar* seafile_deleted_entry_get_obj_name (SeafileDeletedEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_obj_name;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_obj_name (SeafileDeletedEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_obj_name);
	self->priv->_obj_name = _tmp1_;
	g_object_notify ((GObject *) self, "obj-name");
}


const gchar* seafile_deleted_entry_get_basedir (SeafileDeletedEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_basedir;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_basedir (SeafileDeletedEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_basedir);
	self->priv->_basedir = _tmp1_;
	g_object_notify ((GObject *) self, "basedir");
}


gint seafile_deleted_entry_get_mode (SeafileDeletedEntry* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_mode (SeafileDeletedEntry* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mode = _tmp0_;
	g_object_notify ((GObject *) self, "mode");
}


gint seafile_deleted_entry_get_delete_time (SeafileDeletedEntry* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_delete_time;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_delete_time (SeafileDeletedEntry* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_delete_time = _tmp0_;
	g_object_notify ((GObject *) self, "delete-time");
}


gint64 seafile_deleted_entry_get_file_size (SeafileDeletedEntry* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_file_size;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_file_size (SeafileDeletedEntry* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_file_size = _tmp0_;
	g_object_notify ((GObject *) self, "file-size");
}


const gchar* seafile_deleted_entry_get_scan_stat (SeafileDeletedEntry* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_scan_stat;
	result = _tmp0_;
	return result;
}


void seafile_deleted_entry_set_scan_stat (SeafileDeletedEntry* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_scan_stat);
	self->priv->_scan_stat = _tmp1_;
	g_object_notify ((GObject *) self, "scan-stat");
}


static void seafile_deleted_entry_class_init (SeafileDeletedEntryClass * klass) {
	seafile_deleted_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileDeletedEntryPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_deleted_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_deleted_entry_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_deleted_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_COMMIT_ID, g_param_spec_string ("commit-id", "commit-id", "commit-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_OBJ_ID, g_param_spec_string ("obj-id", "obj-id", "obj-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_OBJ_NAME, g_param_spec_string ("obj-name", "obj-name", "obj-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_BASEDIR, g_param_spec_string ("basedir", "basedir", "basedir", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_MODE, g_param_spec_int ("mode", "mode", "mode", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_DELETE_TIME, g_param_spec_int ("delete-time", "delete-time", "delete-time", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_FILE_SIZE, g_param_spec_int64 ("file-size", "file-size", "file-size", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_DELETED_ENTRY_SCAN_STAT, g_param_spec_string ("scan-stat", "scan-stat", "scan-stat", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_deleted_entry_instance_init (SeafileDeletedEntry * self) {
	self->priv = SEAFILE_DELETED_ENTRY_GET_PRIVATE (self);
}


static void seafile_deleted_entry_finalize (GObject* obj) {
	SeafileDeletedEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntry);
	_g_free0 (self->priv->_commit_id);
	_g_free0 (self->priv->_obj_id);
	_g_free0 (self->priv->_obj_name);
	_g_free0 (self->priv->_basedir);
	_g_free0 (self->priv->_scan_stat);
	G_OBJECT_CLASS (seafile_deleted_entry_parent_class)->finalize (obj);
}


GType seafile_deleted_entry_get_type (void) {
	static volatile gsize seafile_deleted_entry_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_deleted_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileDeletedEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_deleted_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileDeletedEntry), 0, (GInstanceInitFunc) seafile_deleted_entry_instance_init, NULL };
		GType seafile_deleted_entry_type_id;
		seafile_deleted_entry_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileDeletedEntry", &g_define_type_info, 0);
		g_once_init_leave (&seafile_deleted_entry_type_id__volatile, seafile_deleted_entry_type_id);
	}
	return seafile_deleted_entry_type_id__volatile;
}


static void _vala_seafile_deleted_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileDeletedEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntry);
	switch (property_id) {
		case SEAFILE_DELETED_ENTRY_COMMIT_ID:
		g_value_set_string (value, seafile_deleted_entry_get_commit_id (self));
		break;
		case SEAFILE_DELETED_ENTRY_OBJ_ID:
		g_value_set_string (value, seafile_deleted_entry_get_obj_id (self));
		break;
		case SEAFILE_DELETED_ENTRY_OBJ_NAME:
		g_value_set_string (value, seafile_deleted_entry_get_obj_name (self));
		break;
		case SEAFILE_DELETED_ENTRY_BASEDIR:
		g_value_set_string (value, seafile_deleted_entry_get_basedir (self));
		break;
		case SEAFILE_DELETED_ENTRY_MODE:
		g_value_set_int (value, seafile_deleted_entry_get_mode (self));
		break;
		case SEAFILE_DELETED_ENTRY_DELETE_TIME:
		g_value_set_int (value, seafile_deleted_entry_get_delete_time (self));
		break;
		case SEAFILE_DELETED_ENTRY_FILE_SIZE:
		g_value_set_int64 (value, seafile_deleted_entry_get_file_size (self));
		break;
		case SEAFILE_DELETED_ENTRY_SCAN_STAT:
		g_value_set_string (value, seafile_deleted_entry_get_scan_stat (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_deleted_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileDeletedEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_DELETED_ENTRY, SeafileDeletedEntry);
	switch (property_id) {
		case SEAFILE_DELETED_ENTRY_COMMIT_ID:
		seafile_deleted_entry_set_commit_id (self, g_value_get_string (value));
		break;
		case SEAFILE_DELETED_ENTRY_OBJ_ID:
		seafile_deleted_entry_set_obj_id (self, g_value_get_string (value));
		break;
		case SEAFILE_DELETED_ENTRY_OBJ_NAME:
		seafile_deleted_entry_set_obj_name (self, g_value_get_string (value));
		break;
		case SEAFILE_DELETED_ENTRY_BASEDIR:
		seafile_deleted_entry_set_basedir (self, g_value_get_string (value));
		break;
		case SEAFILE_DELETED_ENTRY_MODE:
		seafile_deleted_entry_set_mode (self, g_value_get_int (value));
		break;
		case SEAFILE_DELETED_ENTRY_DELETE_TIME:
		seafile_deleted_entry_set_delete_time (self, g_value_get_int (value));
		break;
		case SEAFILE_DELETED_ENTRY_FILE_SIZE:
		seafile_deleted_entry_set_file_size (self, g_value_get_int64 (value));
		break;
		case SEAFILE_DELETED_ENTRY_SCAN_STAT:
		seafile_deleted_entry_set_scan_stat (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileRepoTokenInfo* seafile_repo_token_info_construct (GType object_type) {
	SeafileRepoTokenInfo * self = NULL;
	self = (SeafileRepoTokenInfo*) g_object_new (object_type, NULL);
	return self;
}


SeafileRepoTokenInfo* seafile_repo_token_info_new (void) {
	return seafile_repo_token_info_construct (SEAFILE_TYPE_REPO_TOKEN_INFO);
}


const gchar* seafile_repo_token_info_get_repo_id (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_repo_id (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_repo_token_info_get_repo_name (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_name;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_repo_name (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_name);
	self->priv->_repo_name = _tmp1_;
	g_object_notify ((GObject *) self, "repo-name");
}


const gchar* seafile_repo_token_info_get_repo_owner (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_owner;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_repo_owner (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_owner);
	self->priv->_repo_owner = _tmp1_;
	g_object_notify ((GObject *) self, "repo-owner");
}


const gchar* seafile_repo_token_info_get_email (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_email;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_email (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_email);
	self->priv->_email = _tmp1_;
	g_object_notify ((GObject *) self, "email");
}


const gchar* seafile_repo_token_info_get_token (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_token;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_token (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_token);
	self->priv->_token = _tmp1_;
	g_object_notify ((GObject *) self, "token");
}


const gchar* seafile_repo_token_info_get_peer_id (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_peer_id;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_peer_id (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_peer_id);
	self->priv->_peer_id = _tmp1_;
	g_object_notify ((GObject *) self, "peer-id");
}


const gchar* seafile_repo_token_info_get_peer_ip (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_peer_ip;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_peer_ip (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_peer_ip);
	self->priv->_peer_ip = _tmp1_;
	g_object_notify ((GObject *) self, "peer-ip");
}


const gchar* seafile_repo_token_info_get_peer_name (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_peer_name;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_peer_name (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_peer_name);
	self->priv->_peer_name = _tmp1_;
	g_object_notify ((GObject *) self, "peer-name");
}


gint64 seafile_repo_token_info_get_sync_time (SeafileRepoTokenInfo* self) {
	gint64 result;
	gint64 _tmp0_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_sync_time;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_sync_time (SeafileRepoTokenInfo* self, gint64 value) {
	gint64 _tmp0_ = 0LL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_sync_time = _tmp0_;
	g_object_notify ((GObject *) self, "sync-time");
}


const gchar* seafile_repo_token_info_get_client_ver (SeafileRepoTokenInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_client_ver;
	result = _tmp0_;
	return result;
}


void seafile_repo_token_info_set_client_ver (SeafileRepoTokenInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_client_ver);
	self->priv->_client_ver = _tmp1_;
	g_object_notify ((GObject *) self, "client-ver");
}


static void seafile_repo_token_info_class_init (SeafileRepoTokenInfoClass * klass) {
	seafile_repo_token_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileRepoTokenInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_repo_token_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_repo_token_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_repo_token_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_REPO_NAME, g_param_spec_string ("repo-name", "repo-name", "repo-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_REPO_OWNER, g_param_spec_string ("repo-owner", "repo-owner", "repo-owner", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_EMAIL, g_param_spec_string ("email", "email", "email", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_TOKEN, g_param_spec_string ("token", "token", "token", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_PEER_ID, g_param_spec_string ("peer-id", "peer-id", "peer-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_PEER_IP, g_param_spec_string ("peer-ip", "peer-ip", "peer-ip", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_PEER_NAME, g_param_spec_string ("peer-name", "peer-name", "peer-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_SYNC_TIME, g_param_spec_int64 ("sync-time", "sync-time", "sync-time", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_REPO_TOKEN_INFO_CLIENT_VER, g_param_spec_string ("client-ver", "client-ver", "client-ver", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_repo_token_info_instance_init (SeafileRepoTokenInfo * self) {
	self->priv = SEAFILE_REPO_TOKEN_INFO_GET_PRIVATE (self);
}


static void seafile_repo_token_info_finalize (GObject* obj) {
	SeafileRepoTokenInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfo);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_repo_name);
	_g_free0 (self->priv->_repo_owner);
	_g_free0 (self->priv->_email);
	_g_free0 (self->priv->_token);
	_g_free0 (self->priv->_peer_id);
	_g_free0 (self->priv->_peer_ip);
	_g_free0 (self->priv->_peer_name);
	_g_free0 (self->priv->_client_ver);
	G_OBJECT_CLASS (seafile_repo_token_info_parent_class)->finalize (obj);
}


GType seafile_repo_token_info_get_type (void) {
	static volatile gsize seafile_repo_token_info_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_repo_token_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileRepoTokenInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_repo_token_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileRepoTokenInfo), 0, (GInstanceInitFunc) seafile_repo_token_info_instance_init, NULL };
		GType seafile_repo_token_info_type_id;
		seafile_repo_token_info_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileRepoTokenInfo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_repo_token_info_type_id__volatile, seafile_repo_token_info_type_id);
	}
	return seafile_repo_token_info_type_id__volatile;
}


static void _vala_seafile_repo_token_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileRepoTokenInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfo);
	switch (property_id) {
		case SEAFILE_REPO_TOKEN_INFO_REPO_ID:
		g_value_set_string (value, seafile_repo_token_info_get_repo_id (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_REPO_NAME:
		g_value_set_string (value, seafile_repo_token_info_get_repo_name (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_REPO_OWNER:
		g_value_set_string (value, seafile_repo_token_info_get_repo_owner (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_EMAIL:
		g_value_set_string (value, seafile_repo_token_info_get_email (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_TOKEN:
		g_value_set_string (value, seafile_repo_token_info_get_token (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_ID:
		g_value_set_string (value, seafile_repo_token_info_get_peer_id (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_IP:
		g_value_set_string (value, seafile_repo_token_info_get_peer_ip (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_NAME:
		g_value_set_string (value, seafile_repo_token_info_get_peer_name (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_SYNC_TIME:
		g_value_set_int64 (value, seafile_repo_token_info_get_sync_time (self));
		break;
		case SEAFILE_REPO_TOKEN_INFO_CLIENT_VER:
		g_value_set_string (value, seafile_repo_token_info_get_client_ver (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_repo_token_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileRepoTokenInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_REPO_TOKEN_INFO, SeafileRepoTokenInfo);
	switch (property_id) {
		case SEAFILE_REPO_TOKEN_INFO_REPO_ID:
		seafile_repo_token_info_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_REPO_NAME:
		seafile_repo_token_info_set_repo_name (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_REPO_OWNER:
		seafile_repo_token_info_set_repo_owner (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_EMAIL:
		seafile_repo_token_info_set_email (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_TOKEN:
		seafile_repo_token_info_set_token (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_ID:
		seafile_repo_token_info_set_peer_id (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_IP:
		seafile_repo_token_info_set_peer_ip (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_PEER_NAME:
		seafile_repo_token_info_set_peer_name (self, g_value_get_string (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_SYNC_TIME:
		seafile_repo_token_info_set_sync_time (self, g_value_get_int64 (value));
		break;
		case SEAFILE_REPO_TOKEN_INFO_CLIENT_VER:
		seafile_repo_token_info_set_client_ver (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileSharedUser* seafile_shared_user_construct (GType object_type) {
	SeafileSharedUser * self = NULL;
	self = (SeafileSharedUser*) g_object_new (object_type, NULL);
	return self;
}


SeafileSharedUser* seafile_shared_user_new (void) {
	return seafile_shared_user_construct (SEAFILE_TYPE_SHARED_USER);
}


const gchar* seafile_shared_user_get_repo_id (SeafileSharedUser* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_shared_user_set_repo_id (SeafileSharedUser* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_shared_user_get_user (SeafileSharedUser* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user;
	result = _tmp0_;
	return result;
}


void seafile_shared_user_set_user (SeafileSharedUser* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_user);
	self->priv->_user = _tmp1_;
	g_object_notify ((GObject *) self, "user");
}


const gchar* seafile_shared_user_get_perm (SeafileSharedUser* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_perm;
	result = _tmp0_;
	return result;
}


void seafile_shared_user_set_perm (SeafileSharedUser* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_perm);
	self->priv->_perm = _tmp1_;
	g_object_notify ((GObject *) self, "perm");
}


static void seafile_shared_user_class_init (SeafileSharedUserClass * klass) {
	seafile_shared_user_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileSharedUserPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_shared_user_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_shared_user_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_shared_user_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_USER_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_USER_USER, g_param_spec_string ("user", "user", "user", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_USER_PERM, g_param_spec_string ("perm", "perm", "perm", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_shared_user_instance_init (SeafileSharedUser * self) {
	self->priv = SEAFILE_SHARED_USER_GET_PRIVATE (self);
}


static void seafile_shared_user_finalize (GObject* obj) {
	SeafileSharedUser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_SHARED_USER, SeafileSharedUser);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_user);
	_g_free0 (self->priv->_perm);
	G_OBJECT_CLASS (seafile_shared_user_parent_class)->finalize (obj);
}


GType seafile_shared_user_get_type (void) {
	static volatile gsize seafile_shared_user_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_shared_user_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileSharedUserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_shared_user_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileSharedUser), 0, (GInstanceInitFunc) seafile_shared_user_instance_init, NULL };
		GType seafile_shared_user_type_id;
		seafile_shared_user_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileSharedUser", &g_define_type_info, 0);
		g_once_init_leave (&seafile_shared_user_type_id__volatile, seafile_shared_user_type_id);
	}
	return seafile_shared_user_type_id__volatile;
}


static void _vala_seafile_shared_user_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileSharedUser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SHARED_USER, SeafileSharedUser);
	switch (property_id) {
		case SEAFILE_SHARED_USER_REPO_ID:
		g_value_set_string (value, seafile_shared_user_get_repo_id (self));
		break;
		case SEAFILE_SHARED_USER_USER:
		g_value_set_string (value, seafile_shared_user_get_user (self));
		break;
		case SEAFILE_SHARED_USER_PERM:
		g_value_set_string (value, seafile_shared_user_get_perm (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_shared_user_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileSharedUser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SHARED_USER, SeafileSharedUser);
	switch (property_id) {
		case SEAFILE_SHARED_USER_REPO_ID:
		seafile_shared_user_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_SHARED_USER_USER:
		seafile_shared_user_set_user (self, g_value_get_string (value));
		break;
		case SEAFILE_SHARED_USER_PERM:
		seafile_shared_user_set_perm (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileSharedGroup* seafile_shared_group_construct (GType object_type) {
	SeafileSharedGroup * self = NULL;
	self = (SeafileSharedGroup*) g_object_new (object_type, NULL);
	return self;
}


SeafileSharedGroup* seafile_shared_group_new (void) {
	return seafile_shared_group_construct (SEAFILE_TYPE_SHARED_GROUP);
}


const gchar* seafile_shared_group_get_repo_id (SeafileSharedGroup* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_shared_group_set_repo_id (SeafileSharedGroup* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


gint seafile_shared_group_get_group_id (SeafileSharedGroup* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_group_id;
	result = _tmp0_;
	return result;
}


void seafile_shared_group_set_group_id (SeafileSharedGroup* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_group_id = _tmp0_;
	g_object_notify ((GObject *) self, "group-id");
}


const gchar* seafile_shared_group_get_perm (SeafileSharedGroup* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_perm;
	result = _tmp0_;
	return result;
}


void seafile_shared_group_set_perm (SeafileSharedGroup* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_perm);
	self->priv->_perm = _tmp1_;
	g_object_notify ((GObject *) self, "perm");
}


static void seafile_shared_group_class_init (SeafileSharedGroupClass * klass) {
	seafile_shared_group_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileSharedGroupPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_shared_group_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_shared_group_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_shared_group_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_GROUP_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_GROUP_GROUP_ID, g_param_spec_int ("group-id", "group-id", "group-id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_SHARED_GROUP_PERM, g_param_spec_string ("perm", "perm", "perm", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_shared_group_instance_init (SeafileSharedGroup * self) {
	self->priv = SEAFILE_SHARED_GROUP_GET_PRIVATE (self);
}


static void seafile_shared_group_finalize (GObject* obj) {
	SeafileSharedGroup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroup);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_perm);
	G_OBJECT_CLASS (seafile_shared_group_parent_class)->finalize (obj);
}


GType seafile_shared_group_get_type (void) {
	static volatile gsize seafile_shared_group_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_shared_group_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileSharedGroupClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_shared_group_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileSharedGroup), 0, (GInstanceInitFunc) seafile_shared_group_instance_init, NULL };
		GType seafile_shared_group_type_id;
		seafile_shared_group_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileSharedGroup", &g_define_type_info, 0);
		g_once_init_leave (&seafile_shared_group_type_id__volatile, seafile_shared_group_type_id);
	}
	return seafile_shared_group_type_id__volatile;
}


static void _vala_seafile_shared_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileSharedGroup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroup);
	switch (property_id) {
		case SEAFILE_SHARED_GROUP_REPO_ID:
		g_value_set_string (value, seafile_shared_group_get_repo_id (self));
		break;
		case SEAFILE_SHARED_GROUP_GROUP_ID:
		g_value_set_int (value, seafile_shared_group_get_group_id (self));
		break;
		case SEAFILE_SHARED_GROUP_PERM:
		g_value_set_string (value, seafile_shared_group_get_perm (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_shared_group_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileSharedGroup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_SHARED_GROUP, SeafileSharedGroup);
	switch (property_id) {
		case SEAFILE_SHARED_GROUP_REPO_ID:
		seafile_shared_group_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_SHARED_GROUP_GROUP_ID:
		seafile_shared_group_set_group_id (self, g_value_get_int (value));
		break;
		case SEAFILE_SHARED_GROUP_PERM:
		seafile_shared_group_set_perm (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SeafileEncryptionInfo* seafile_encryption_info_construct (GType object_type) {
	SeafileEncryptionInfo * self = NULL;
	self = (SeafileEncryptionInfo*) g_object_new (object_type, NULL);
	return self;
}


SeafileEncryptionInfo* seafile_encryption_info_new (void) {
	return seafile_encryption_info_construct (SEAFILE_TYPE_ENCRYPTION_INFO);
}


const gchar* seafile_encryption_info_get_repo_id (SeafileEncryptionInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}


void seafile_encryption_info_set_repo_id (SeafileEncryptionInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_repo_id);
	self->priv->_repo_id = _tmp1_;
	g_object_notify ((GObject *) self, "repo-id");
}


const gchar* seafile_encryption_info_get_passwd (SeafileEncryptionInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_passwd;
	result = _tmp0_;
	return result;
}


void seafile_encryption_info_set_passwd (SeafileEncryptionInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_passwd);
	self->priv->_passwd = _tmp1_;
	g_object_notify ((GObject *) self, "passwd");
}


gint seafile_encryption_info_get_enc_version (SeafileEncryptionInfo* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_enc_version;
	result = _tmp0_;
	return result;
}


void seafile_encryption_info_set_enc_version (SeafileEncryptionInfo* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_enc_version = _tmp0_;
	g_object_notify ((GObject *) self, "enc-version");
}


const gchar* seafile_encryption_info_get_magic (SeafileEncryptionInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_magic;
	result = _tmp0_;
	return result;
}


void seafile_encryption_info_set_magic (SeafileEncryptionInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_magic);
	self->priv->_magic = _tmp1_;
	g_object_notify ((GObject *) self, "magic");
}


const gchar* seafile_encryption_info_get_random_key (SeafileEncryptionInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_random_key;
	result = _tmp0_;
	return result;
}


void seafile_encryption_info_set_random_key (SeafileEncryptionInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_random_key);
	self->priv->_random_key = _tmp1_;
	g_object_notify ((GObject *) self, "random-key");
}


static void seafile_encryption_info_class_init (SeafileEncryptionInfoClass * klass) {
	seafile_encryption_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeafileEncryptionInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_encryption_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_encryption_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_encryption_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_ENCRYPTION_INFO_REPO_ID, g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_ENCRYPTION_INFO_PASSWD, g_param_spec_string ("passwd", "passwd", "passwd", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_ENCRYPTION_INFO_ENC_VERSION, g_param_spec_int ("enc-version", "enc-version", "enc-version", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_ENCRYPTION_INFO_MAGIC, g_param_spec_string ("magic", "magic", "magic", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_ENCRYPTION_INFO_RANDOM_KEY, g_param_spec_string ("random-key", "random-key", "random-key", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void seafile_encryption_info_instance_init (SeafileEncryptionInfo * self) {
	self->priv = SEAFILE_ENCRYPTION_INFO_GET_PRIVATE (self);
}


static void seafile_encryption_info_finalize (GObject* obj) {
	SeafileEncryptionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfo);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_passwd);
	_g_free0 (self->priv->_magic);
	_g_free0 (self->priv->_random_key);
	G_OBJECT_CLASS (seafile_encryption_info_parent_class)->finalize (obj);
}


GType seafile_encryption_info_get_type (void) {
	static volatile gsize seafile_encryption_info_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_encryption_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileEncryptionInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_encryption_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileEncryptionInfo), 0, (GInstanceInitFunc) seafile_encryption_info_instance_init, NULL };
		GType seafile_encryption_info_type_id;
		seafile_encryption_info_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileEncryptionInfo", &g_define_type_info, 0);
		g_once_init_leave (&seafile_encryption_info_type_id__volatile, seafile_encryption_info_type_id);
	}
	return seafile_encryption_info_type_id__volatile;
}


static void _vala_seafile_encryption_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SeafileEncryptionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfo);
	switch (property_id) {
		case SEAFILE_ENCRYPTION_INFO_REPO_ID:
		g_value_set_string (value, seafile_encryption_info_get_repo_id (self));
		break;
		case SEAFILE_ENCRYPTION_INFO_PASSWD:
		g_value_set_string (value, seafile_encryption_info_get_passwd (self));
		break;
		case SEAFILE_ENCRYPTION_INFO_ENC_VERSION:
		g_value_set_int (value, seafile_encryption_info_get_enc_version (self));
		break;
		case SEAFILE_ENCRYPTION_INFO_MAGIC:
		g_value_set_string (value, seafile_encryption_info_get_magic (self));
		break;
		case SEAFILE_ENCRYPTION_INFO_RANDOM_KEY:
		g_value_set_string (value, seafile_encryption_info_get_random_key (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_seafile_encryption_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SeafileEncryptionInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_ENCRYPTION_INFO, SeafileEncryptionInfo);
	switch (property_id) {
		case SEAFILE_ENCRYPTION_INFO_REPO_ID:
		seafile_encryption_info_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_ENCRYPTION_INFO_PASSWD:
		seafile_encryption_info_set_passwd (self, g_value_get_string (value));
		break;
		case SEAFILE_ENCRYPTION_INFO_ENC_VERSION:
		seafile_encryption_info_set_enc_version (self, g_value_get_int (value));
		break;
		case SEAFILE_ENCRYPTION_INFO_MAGIC:
		seafile_encryption_info_set_magic (self, g_value_get_string (value));
		break;
		case SEAFILE_ENCRYPTION_INFO_RANDOM_KEY:
		seafile_encryption_info_set_random_key (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



